{"version":3,"sources":["fixtures.js","gridList.js","init.js","jquery.gridList.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"grid-list.js","sourcesContent":["// Class for easily creating grid elements\r\n// TODO: Add save (serialize) function to serialize all gridItems(with their pos) to a cookie\r\nclass GridItem {\r\n    constructor(width, height, x, y, image = null, link = null){\r\n        this.id = gridItems.length; // Make sure it has a unique id\r\n        this.width = width;\r\n        this.height = height;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.image = image;\r\n        this.link = link;\r\n        this.createHTML(link, image);\r\n\r\n        // Push this object to the gridItems list\r\n        gridItems.push(this);\r\n    }\r\n\r\n    createHTML(link = null, image = null){\r\n        this.html = $(\r\n            '<li data-id='+this.id+'>' +\r\n                '<div class=\"inner\">' +\r\n                    '<div class=\"controls\">' +\r\n                        '<a href=\"#zoom1\" class=\"edit\" data-a=\"resize\" data-w=\"1\" data-h=\"1\">1x1</a>' +\r\n                        '<a href=\"#zoom2\" class=\"edit\" data-a=\"resize\" data-w=\"2\" data-h=\"1\">2x1</a>' +\r\n                        '<a href=\"#zoom1\" class=\"edit\" data-a=\"resize\" data-w=\"1\" data-h=\"2\">1x2</a>' +\r\n                        '<a href=\"#zoom2\" class=\"edit\" data-a=\"resize\" data-w=\"2\" data-h=\"2\">2x2</a>' +\r\n                        '<a href=\"#edit\" class=\"edit\" data-a=\"edit\">edit</a>' +\r\n                    '</div>' +\r\n                    (link!==(null)?'<a href='+link+'>':'') +\r\n                        (image!==(null)?'<img src='+image+' class=\"image\">':'<div style=\"width:100%; height:100%; background-color: '+randomColor('rgb')+'\"></div>') +\r\n                    (link!==(null)?'</a>':'') +\r\n                '</div>' +\r\n            '</li>'\r\n        );\r\n    }\r\n\r\n    toJSON(){\r\n        return {\r\n            id: this.id,\r\n            width: this.width,\r\n            height: this.height,\r\n            x: this.x,\r\n            y: this.y,\r\n            image: this.image,\r\n            link: this.link,\r\n            // html: this.html\r\n        };\r\n    }\r\n}\r\n\r\nvar gridItems = [];\r\nvar fixtures = {};\r\n\r\nfixtures.GRID1 = [\r\n        new GridItem(1,1,0,0,\"https://www.nasa.gov/sites/default/files/styles/image_card_4x3_ratio/public/thumbnails/image/leisa_christmas_false_color.png?itok=Jxf0IlS4\", \"https://www.google.com\"),\r\n        new GridItem(1,2,1,0),\r\n        new GridItem(1,1,2,0),\r\n        new GridItem(1,1,3,0),\r\n        new GridItem(1,1,4,0),\r\n        new GridItem(1,1,0,1),\r\n        new GridItem(1,1,2,1),\r\n        new GridItem(1,1,3,1),\r\n    ];\r\n\r\n// Enable Node module\r\nif (typeof(require) == 'function') {\r\n    for (var k in fixtures) {\r\n        exports[k] = fixtures[k];\r\n    }\r\n}\r\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.GridList = factory();\n  }\n}(this, function() {\n\nvar GridList = function(items, options) {\n  /**\n   * A GridList manages the two-dimensional positions from a list of items,\n   * within a virtual matrix.\n   *\n   * The GridList's main function is to convert the item positions from one\n   * grid size to another, maintaining as much of their order as possible.\n   *\n   * The GridList's second function is to handle collisions when moving an item\n   * over another.\n   *\n   * The positioning algorithm places items in columns. Starting from left to\n   * right, going through each column top to bottom.\n   *\n   * The size of an item is expressed using the number of cols and rows it\n   * takes up within the grid (w and h)\n   *\n   * The position of an item is express using the col and row position within\n   * the grid (x and y)\n   *\n   * An item is an object of structure:\n   * {\n   *   w: 3, h: 1,\n   *   x: 0, y: 1\n   * }\n   */\n\n  this._options = options;\n  for (var k in this.defaults) {\n    if (!this._options.hasOwnProperty(k)) {\n      this._options[k] = this.defaults[k];\n    }\n  }\n\n  this.items = items;\n\n  this._adjustSizeOfItems();\n\n  this.generateGrid();\n};\n\nGridList.cloneItems = function(items, _items) {\n  /**\n   * Clone items with a deep level of one. Items are not referenced but their\n   * properties are\n   */\n  var _item,\n      i,\n      k;\n  if (_items === undefined) {\n    _items = [];\n  }\n  for (i = 0; i < items.length; i++) {\n    // XXX: this is good because we don't want to lose item reference, but\n    // maybe we should clear their properties since some might be optional\n    if (!_items[i]) {\n      _items[i] = {};\n    }\n    for (k in items[i]) {\n      _items[i][k] = items[i][k];\n    }\n  }\n  return _items;\n};\n\nGridList.prototype = {\n\n  defaults: {\n    lanes: 5,\n    direction: 'horizontal'\n  },\n\n  /**\n   * Illustates grid as text-based table, using a number identifier for each\n   * item. E.g.\n   *\n   *  #|  0  1  2  3  4  5  6  7  8  9 10 11 12 13\n   *  --------------------------------------------\n   *  0| 00 02 03 04 04 06 08 08 08 12 12 13 14 16\n   *  1| 01 -- 03 05 05 07 09 10 11 11 -- 13 15 --\n   *\n   * Warn: Does not work if items don't have a width or height specified\n   * besides their position in the grid.\n   */\n  toString: function() {\n    var widthOfGrid = this.grid.length,\n        output = '\\n #|',\n        border = '\\n --',\n        item,\n        i,\n        j;\n\n    // Render the table header\n    for (i = 0; i < widthOfGrid; i++) {\n      output += ' ' + this._padNumber(i, ' ');\n      border += '---';\n    };\n    output += border;\n\n    // Render table contents row by row, as we go on the y axis\n    for (i = 0; i < this._options.lanes; i++) {\n      output += '\\n' + this._padNumber(i, ' ') + '|';\n      for (j = 0; j < widthOfGrid; j++) {\n        output += ' ';\n        item = this.grid[j][i];\n        output += item ? this._padNumber(this.items.indexOf(item), '0') : '--';\n      }\n    };\n    output += '\\n';\n    return output;\n  },\n\n  generateGrid: function() {\n    /**\n     * Build the grid structure from scratch, with the current item positions\n     */\n    var i;\n    this._resetGrid();\n    for (i = 0; i < this.items.length; i++) {\n      this._markItemPositionToGrid(this.items[i]);\n    }\n  },\n\n  resizeGrid: function(lanes) {\n    var currentColumn = 0;\n\n    this._options.lanes = lanes;\n    this._adjustSizeOfItems();\n\n    this._sortItemsByPosition();\n    this._resetGrid();\n\n    // The items will be sorted based on their index within the this.items array,\n    // that is their \"1d position\"\n    for (var i = 0; i < this.items.length; i++) {\n      var item = this.items[i],\n          position = this._getItemPosition(item);\n\n      this._updateItemPosition(\n        item, this.findPositionForItem(item, {x: currentColumn, y: 0}));\n\n      // New items should never be placed to the left of previous items\n      currentColumn = Math.max(currentColumn, position.x);\n    }\n\n    this._pullItemsToLeft();\n  },\n\n  findPositionForItem: function(item, start, fixedRow) {\n    /**\n     * This method has two options for the position we want for the item:\n     * - Starting from a certain row/column number and only looking for\n     *   positions to its right\n     * - Accepting positions for a certain row number only (use-case: items\n     *   being shifted to the left/right as a result of collisions)\n     *\n     * @param {Object<x:Number, y:Number, w:Number, h:Number} item\n     * @param {Object<x:Number, y:Number} start Position from which to start\n     *     the search.\n     * @param {Number} [fixedRow] If provided, we're going to try to find a\n     *     position for the new item on it. If doesn't fit there, we're going\n     *     to put it on the first row.\n     *\n     * @returns {Number[2]} x and y.\n     */\n\n    var x, y, position;\n\n    // Start searching for a position from the horizontal position of the\n    // rightmost item from the grid\n    for (x = start.x; x < this.grid.length; x++) {\n      if (fixedRow !== undefined) {\n        position = [x, fixedRow];\n\n        if (this._itemFitsAtPosition(item, position)) {\n          return position;\n        }\n      } else {\n        for (y = start.y; y < this._options.lanes; y++) {\n          position = [x, y];\n\n          if (this._itemFitsAtPosition(item, position)) {\n            return position;\n          }\n        }\n      }\n    }\n\n    // If we've reached this point, we need to start a new column\n    var newCol = this.grid.length,\n        newRow = 0;\n\n    if (fixedRow !== undefined &&\n        this._itemFitsAtPosition(item, [newCol, fixedRow])) {\n      newRow = fixedRow;\n    }\n\n    return [newCol, newRow];\n  },\n\n  moveItemToPosition: function(item, newPosition) {\n    var position = this._getItemPosition({\n      x: newPosition[0],\n      y: newPosition[1],\n      w: item.w,\n      h: item.h\n    });\n\n    this._updateItemPosition(item, [position.x, position.y]);\n    this._resolveCollisions(item);\n  },\n\n  resizeItem: function(item, size) {\n    /**\n     * Resize an item and resolve collisions.\n     *\n     * @param {Object} item A reference to an item that's part of the grid.\n     * @param {Object} size\n     * @param {Number} [size.w=item.w] The new width.\n     * @param {Number} [size.h=item.h] The new height.\n     */\n\n    var width = size.w || item.w,\n        height = size.h || item.h;\n\n    this._updateItemSize(item, width, height);\n\n    this._resolveCollisions(item);\n\n    this._pullItemsToLeft();\n  },\n\n  getChangedItems: function(initialItems, idAttribute) {\n    /**\n     * Compare the current items against a previous snapshot and return only\n     * the ones that changed their attributes in the meantime. This includes both\n     * position (x, y) and size (w, h)\n     *\n     * Since both their position and size can change, the items need an\n     * additional identifier attribute to match them with their previous state\n     */\n    var changedItems = [];\n\n    for (var i = 0; i < initialItems.length; i++) {\n      var item = this._getItemByAttribute(idAttribute,\n                                          initialItems[i][idAttribute]);\n\n      if (item.x !== initialItems[i].x ||\n          item.y !== initialItems[i].y ||\n          item.w !== initialItems[i].w ||\n          item.h !== initialItems[i].h) {\n        changedItems.push(item);\n      }\n    }\n\n    return changedItems;\n  },\n\n  _sortItemsByPosition: function() {\n    this.items.sort(function(item1, item2) {\n      var position1 = this._getItemPosition(item1),\n          position2 = this._getItemPosition(item2);\n\n      // Try to preserve columns.\n      if (position1.x != position2.x) {\n        return position1.x - position2.x;\n      }\n\n      if (position1.y != position2.y) {\n        return position1.y - position2.y;\n      }\n\n      // The items are placed on the same position.\n      return 0;\n    }.bind(this));\n  },\n\n  _adjustSizeOfItems: function() {\n    /**\n     * Some items can have 100% height or 100% width. Those dimmensions are\n     * expressed as 0. We need to ensure a valid width and height for each of\n     * those items as the number of items per lane.\n     */\n\n    for (var i = 0; i < this.items.length; i++) {\n      var item = this.items[i];\n\n      // This can happen only the first time items are checked.\n      // We need the property to have a value for all the items so that the\n      // `cloneItems` method will merge the properties properly. If we only set\n      // it to the items that need it then the following can happen:\n      //\n      // cloneItems([{id: 1, autoSize: true}, {id: 2}],\n      //            [{id: 2}, {id: 1, autoSize: true}]);\n      //\n      // will result in\n      //\n      // [{id: 1, autoSize: true}, {id: 2, autoSize: true}]\n      if (item.autoSize === undefined) {\n        item.autoSize = item.w === 0 || item.h === 0;\n      }\n\n      if (item.autoSize) {\n        if (this._options.direction === 'horizontal') {\n          item.h = this._options.lanes;\n        } else {\n          item.w = this._options.lanes;\n        }\n      }\n    }\n  },\n\n  _resetGrid: function() {\n    this.grid = [];\n  },\n\n  _itemFitsAtPosition: function(item, newPosition) {\n    /**\n     * Check that an item wouldn't overlap with another one if placed at a\n     * certain position within the grid\n     */\n\n    var position = this._getItemPosition(item),\n        x, y, row;\n\n    // No coordonate can be negative\n    if (newPosition[0] < 0 || newPosition[1] < 0) {\n      return false;\n    }\n\n    // Make sure the item isn't larger than the entire grid\n    if (newPosition[1] + position.h > this._options.lanes) {\n      return false;\n    }\n\n    // Make sure the position doesn't overlap with an already positioned\n    // item.\n    for (x = newPosition[0]; x < newPosition[0] + position.w; x++) {\n      var col = this.grid[x];\n\n      // Surely a column that hasn't even been created yet is available\n      if (!col) {\n        continue;\n      }\n\n      for (y = newPosition[1]; y < newPosition[1] + position.h; y++) {\n        // Any space occupied by an item can continue to be occupied by the\n        // same item.\n        if (col[y] && col[y] !== item) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  },\n\n  _updateItemPosition: function(item, position) {\n    if (item.x !== null && item.y !== null) {\n      this._deleteItemPositionFromGrid(item);\n    }\n\n    this._setItemPosition(item, position);\n\n    this._markItemPositionToGrid(item);\n  },\n\n  _updateItemSize: function(item, width, height) {\n    /**\n     * @param {Object} item A reference to a grid item.\n     * @param {Number} width The new width.\n     * @param {Number} height The new height.\n     */\n\n    if (item.x !== null && item.y !== null) {\n      this._deleteItemPositionFromGrid(item);\n    }\n\n    item.w = width;\n    item.h = height;\n\n    this._markItemPositionToGrid(item);\n  },\n\n  _markItemPositionToGrid: function(item) {\n    /**\n     * Mark the grid cells that are occupied by an item. This prevents items\n     * from overlapping in the grid\n     */\n\n    var position = this._getItemPosition(item),\n        x, y;\n\n    // Ensure that the grid has enough columns to accomodate the current item.\n    this._ensureColumns(position.x + position.w);\n\n    for (x = position.x; x < position.x + position.w; x++) {\n      for (y = position.y; y < position.y + position.h; y++) {\n        this.grid[x][y] = item;\n      }\n    }\n  },\n\n  _deleteItemPositionFromGrid: function(item) {\n    var position = this._getItemPosition(item),\n        x, y;\n\n    for (x = position.x; x < position.x + position.w; x++) {\n      // It can happen to try to remove an item from a position not generated\n      // in the grid, probably when loading a persisted grid of items. No need\n      // to create a column to be able to remove something from it, though\n      if (!this.grid[x]) {\n        continue;\n      }\n\n      for (y = position.y; y < position.y + position.h; y++) {\n        // Don't clear the cell if it's been occupied by a different widget in\n        // the meantime (e.g. when an item has been moved over this one, and\n        // thus by continuing to clear this item's previous position you would\n        // cancel the first item's move, leaving it without any position even)\n        if (this.grid[x][y] == item) {\n          this.grid[x][y] = null;\n        }\n      }\n    }\n  },\n\n  _ensureColumns: function(N) {\n    /**\n     * Ensure that the grid has at least N columns available.\n     */\n    var i;\n    for (i = 0; i < N; i++) {\n      if (!this.grid[i]) {\n        this.grid.push(new GridCol(this._options.lanes));\n      }\n    }\n  },\n\n  _getItemsCollidingWithItem: function(item) {\n    var collidingItems = [];\n    for (var i = 0; i < this.items.length; i++) {\n      if (item != this.items[i] &&\n          this._itemsAreColliding(item, this.items[i])) {\n        collidingItems.push(i);\n      }\n    }\n    return collidingItems;\n  },\n\n  _itemsAreColliding: function(item1, item2) {\n    var position1 = this._getItemPosition(item1),\n        position2 = this._getItemPosition(item2);\n\n    return !(position2.x >= position1.x + position1.w ||\n             position2.x + position2.w <= position1.x ||\n             position2.y >= position1.y + position1.h ||\n             position2.y + position2.h <= position1.y);\n  },\n\n  _resolveCollisions: function(item) {\n    if (!this._tryToResolveCollisionsLocally(item)) {\n      this._pullItemsToLeft(item);\n    }\n    this._pullItemsToLeft();\n  },\n\n  _tryToResolveCollisionsLocally: function(item) {\n    /**\n     * Attempt to resolve the collisions after moving a an item over one or more\n     * other items within the grid, by shifting the position of the colliding\n     * items around the moving one. This might result in subsequent collisions,\n     * in which case we will revert all position permutations. To be able to\n     * revert to the initial item positions, we create a virtual grid in the\n     * process\n     */\n    var collidingItems = this._getItemsCollidingWithItem(item);\n    if (!collidingItems.length) {\n      return true;\n    }\n    var _gridList = new GridList([], this._options),\n        leftOfItem,\n        rightOfItem,\n        aboveOfItem,\n        belowOfItem;\n\n    GridList.cloneItems(this.items, _gridList.items);\n    _gridList.generateGrid();\n\n    for (var i = 0; i < collidingItems.length; i++) {\n      var collidingItem = _gridList.items[collidingItems[i]],\n          collidingPosition = this._getItemPosition(collidingItem);\n\n      // We use a simple algorithm for moving items around when collisions occur:\n      // In this prioritized order, we try to move a colliding item around the\n      // moving one:\n      // 1. to its left side\n      // 2. above it\n      // 3. under it\n      // 4. to its right side\n      var position = this._getItemPosition(item);\n\n      leftOfItem = [position.x - collidingPosition.w, collidingPosition.y];\n      rightOfItem = [position.x + position.w, collidingPosition.y];\n      aboveOfItem = [collidingPosition.x, position.y - collidingPosition.h];\n      belowOfItem = [collidingPosition.x, position.y + position.h];\n\n      if (_gridList._itemFitsAtPosition(collidingItem, leftOfItem)) {\n        _gridList._updateItemPosition(collidingItem, leftOfItem);\n      } else if (_gridList._itemFitsAtPosition(collidingItem, aboveOfItem)) {\n        _gridList._updateItemPosition(collidingItem, aboveOfItem);\n      } else if (_gridList._itemFitsAtPosition(collidingItem, belowOfItem)) {\n        _gridList._updateItemPosition(collidingItem, belowOfItem);\n      } else if (_gridList._itemFitsAtPosition(collidingItem, rightOfItem)) {\n        _gridList._updateItemPosition(collidingItem, rightOfItem);\n      } else {\n        // Collisions failed, we must use the pullItemsToLeft method to arrange\n        // the other items around this item with fixed position. This is our\n        // plan B for when local collision resolving fails.\n        return false;\n      }\n    }\n    // If we reached this point it means we managed to resolve the collisions\n    // from one single iteration, just by moving the colliding items around. So\n    // we accept this scenario and marge the brached-out grid instance into the\n    // original one\n    GridList.cloneItems(_gridList.items, this.items);\n    this.generateGrid();\n    return true;\n  },\n\n  _pullItemsToLeft: function(fixedItem) {\n    /**\n     * Build the grid from scratch, by using the current item positions and\n     * pulling them as much to the left as possible, removing as space between\n     * them as possible.\n     *\n     * If a \"fixed item\" is provided, its position will be kept intact and the\n     * rest of the items will be layed around it.\n     */\n\n\n    // Start a fresh grid with the fixed item already placed inside\n    this._sortItemsByPosition();\n    this._resetGrid();\n\n    // Start the grid with the fixed item as the first positioned item\n    if (fixedItem) {\n      var fixedPosition = this._getItemPosition(fixedItem);\n      this._updateItemPosition(fixedItem, [fixedPosition.x, fixedPosition.y]);\n    }\n\n    for (var i = 0; i < this.items.length; i++) {\n      var item = this.items[i],\n          position = this._getItemPosition(item);\n\n      // The fixed item keeps its exact position\n      if (fixedItem && item == fixedItem) {\n        continue;\n      }\n\n      var x = this._findLeftMostPositionForItem(item),\n          newPosition = this.findPositionForItem(\n            item, {x: x, y: 0}, position.y);\n\n      this._updateItemPosition(item, newPosition);\n    }\n  },\n\n  _findLeftMostPositionForItem: function(item) {\n    /**\n     * When pulling items to the left, we need to find the leftmost position for\n     * an item, with two considerations in mind:\n     * - preserving its current row\n     * - preserving the previous horizontal order between items\n     */\n\n    var tail = 0,\n        position = this._getItemPosition(item);\n\n    for (var i = 0; i < this.grid.length; i++) {\n      for (var j = position.y; j < position.y + position.h; j++) {\n        var otherItem = this.grid[i][j];\n\n        if (!otherItem) {\n          continue;\n        }\n\n        var otherPosition = this._getItemPosition(otherItem);\n\n        if (this.items.indexOf(otherItem) < this.items.indexOf(item)) {\n          tail = otherPosition.x + otherPosition.w;\n        }\n      }\n    }\n\n    return tail;\n  },\n\n  _getItemByAttribute: function(key, value) {\n    for (var i = 0; i < this.items.length; i++) {\n      if (this.items[i][key] === value) {\n        return this.items[i];\n      }\n    }\n    return null;\n  },\n\n  _padNumber: function(nr, prefix) {\n    // Currently works for 2-digit numbers (<100)\n    return nr >= 10 ? nr : prefix + nr;\n  },\n\n  _getItemPosition: function(item) {\n    /**\n     * If the direction is vertical we need to rotate the grid 90 deg to the\n     * left. Thus, we simulate the fact that items are being pulled to the top.\n     *\n     * Since the items have widths and heights, if we apply the classic\n     * counter-clockwise 90 deg rotation\n     *\n     *     [0 -1]\n     *     [1  0]\n     *\n     * then the top left point of an item will become the bottom left point of\n     * the rotated item. To adjust for this, we need to subtract from the y\n     * position the height of the original item - the width of the rotated item.\n     *\n     * However, if we do this then we'll reverse some actions: resizing the\n     * width of an item will stretch the item to the left instead of to the\n     * right; resizing an item that doesn't fit into the grid will push the\n     * items around it instead of going on a new row, etc.\n     *\n     * We found it better to do a vertical flip of the grid after rotating it.\n     * This restores the direction of the actions and greatly simplifies the\n     * transformations.\n     */\n\n    if (this._options.direction === 'horizontal') {\n      return item;\n    } else {\n      return {\n        x: item.y,\n        y: item.x,\n        w: item.h,\n        h: item.w\n      };\n    }\n  },\n\n  _setItemPosition: function(item, position) {\n    /**\n     * See _getItemPosition.\n     */\n\n    if (this._options.direction === 'horizontal') {\n      item.x = position[0];\n      item.y = position[1];\n    } else {\n      // We're supposed to subtract the rotated item's height which is actually\n      // the non-rotated item's width.\n      item.x = position[1];\n      item.y = position[0];\n    }\n  }\n};\n\nvar GridCol = function(lanes) {\n  for (var i = 0; i < lanes; i++) {\n    this.push(null);\n  }\n};\n\n// Extend the Array prototype\nGridCol.prototype = [];\n\n// This module will have direct access to the GridList class\nreturn GridList;\n\n}));\n","$(document).ready(function(){\r\n    createGrid(fixtures.GRID1);\r\n});\r\n\r\nvar Grid = {\r\n    currentSize: 4, // Amount of rows\r\n    buildElements: function($gridContainer, items) { // Create the items\r\n        var item, i;\r\n        for (i = 0; i < items.length; i++) {\r\n            item = items[i];\r\n            $item = item.html;\r\n            $item.attr({\r\n                'data-w': item.width,\r\n                'data-h': item.height,\r\n                'data-x': item.x,\r\n                'data-y': item.y\r\n            });\r\n            $gridContainer.append($item);\r\n        }\r\n    },\r\n    resize: function(size) {\r\n        if (size) {\r\n            this.currentSize = size;\r\n        }\r\n        $('#grid').gridList('resize', this.currentSize);\r\n    },\r\n    // flashItems: function(items) {\r\n    //     // Hack to flash changed items visually\r\n    //     for (var i = 0; i < items.length; i++) {\r\n    //         (function($element) {\r\n    //             $element.addClass('changed');\r\n    //             setTimeout(function() {\r\n    //                 $element.removeClass('changed');\r\n    //             }, 0);\r\n    //         })(items[i].$element);\r\n    //     }\r\n    // }\r\n};\r\n\r\n$(window).resize(function() {\r\n    $('#grid').gridList('reflow');\r\n});\r\n\r\nfunction createGrid(itemCollection) {\r\n    // Clear the grid\r\n    $(\"#grid\").empty();\r\n\r\n    // Build the items\r\n    Grid.buildElements($('#grid'), itemCollection);\r\n\r\n    // Convert the UL to a gridList\r\n    $('#grid').gridList({\r\n        lanes: Grid.currentSize,\r\n        widthHeightRatio: 264 / 294,\r\n        heightToFontSizeRatio: 0.25,\r\n        onChange: function(changedItems) {\r\n            // Save the new positions to the objects\r\n            $.each(changedItems, function(index, item){\r\n                var gridItem = gridItems[item.id];\r\n                gridItem.x = item.x;\r\n                gridItem.y = item.y;\r\n                gridItems[gridItem.id] = gridItem;\r\n            });\r\n\r\n            // Convert to JSON\r\n            // console.log(JSON.stringify(gridItems));\r\n            // TODO: Save the JSON string to a cookie\r\n            var username = 'JohnDoe'; // TODO: Get logged in username\r\n            var grid = JSON.stringify(gridItems);\r\n\r\n            var date_obj = new Date();\r\n            date_obj.setMonth(date_obj.getMonth() + 1); // Define lifetime of the cookie\r\n            var exp_date = date_obj.toUTCString();//.setMonth(new Date().getMonth() + 1);//.toUTCString();\r\n            console.log(exp_date);\r\n        }\r\n    });\r\n\r\n    // Eventhandler for the control buttons\r\n    $('#grid li .edit').click(function(e) {\r\n        e.preventDefault();\r\n        var itemElement = $(e.currentTarget).closest('li');\r\n        var gridItem = gridItems[itemElement.data('id')];\r\n        var itemAction = $(e.currentTarget).data('a');\r\n\r\n        if(itemAction == 'resize')\r\n        {\r\n            // Resize grid item according to given data\r\n            $('#grid').gridList('resizeItem', itemElement, {\r\n                w: $(e.currentTarget).data('w'),\r\n                h: $(e.currentTarget).data('h')\r\n            });\r\n\r\n            // Save the changes to the object\r\n            gridItem.width = $(e.currentTarget).data('w');\r\n            gridItem.height = $(e.currentTarget).data('h');\r\n            // gridItem.createHTML();\r\n            gridItems[gridItem.id] = gridItem;\r\n        }\r\n        else if(itemAction == 'edit')\r\n        {\r\n            // Open modal to edit the grid items properties\r\n            $(\"#edit_id\").val(gridItem.id);\r\n            $(\"#edit_link\").val(gridItem.link!==(null)?gridItem.link:'');\r\n            $(\"#edit_image\").val(gridItem.image!==(null)?gridItem.image:'');\r\n            $(\"#modal_edit\").modal('show');\r\n        }\r\n    });\r\n\r\n    // Eventhandler for saving edit modal\r\n    $('#edit_save').on('click', function(e){\r\n        // Update grid item and refresh the grid\r\n        // TODO: Expand Form validation\r\n        // TODO: Improve performance\r\n        var gridItem = gridItems[$(\"#edit_id\").val()];\r\n        var link = null, image = null;\r\n        if($(\"#edit_link\").val() != '')\r\n            link = $(\"#edit_link\").val(); // TODO: Check if we need to add 'http' prefix? Otherwise laravel returns an error...\r\n        if($(\"#edit_image\").val() != '')\r\n            image = $(\"#edit_image\").val();\r\n        gridItem.createHTML(link, image);\r\n        gridItems[gridItem.id] = gridItem;\r\n\r\n        // Recreate the grid\r\n        createGrid(gridItems);\r\n\r\n        // Hide the modal\r\n        $(\"#modal_edit\").modal('hide');\r\n    });\r\n\r\n    //// Adds a row to the grid\r\n    // $('.add-row').click(function(e) {\r\n    //     e.preventDefault();\r\n    //     Grid.resize(Grid.currentSize + 1);\r\n    // });\r\n\r\n    //// Removes a row from the grid\r\n    // $('.remove-row').click(function(e) {\r\n    //     e.preventDefault();\r\n    //     Grid.resize(Math.max(1, Grid.currentSize - 1));\r\n    // });\r\n};","// It does not try to register in a CommonJS environment since jQuery is not\n// likely to run in those environments.\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery', 'gridlist'], factory);\n  } else {\n    factory(jQuery, GridList);\n  }\n}(function($, GridList) {\n\n  var DraggableGridList = function(element, options, draggableOptions) {\n    this.options = $.extend({}, this.defaults, options);\n    this.draggableOptions = $.extend(\n      {}, this.draggableDefaults, draggableOptions);\n\n    this.$element = $(element);\n    this._init();\n    this._bindEvents();\n  };\n\n  DraggableGridList.prototype = {\n\n    defaults: {\n      lanes: 5,\n      direction: \"horizontal\",\n      itemSelector: 'li[data-w]',\n      widthHeightRatio: 1,\n      dragAndDrop: true\n    },\n\n    draggableDefaults: {\n      zIndex: 2,\n      scroll: false,\n      containment: \"parent\"\n    },\n\n    destroy: function() {\n      this._unbindEvents();\n    },\n\n    resize: function(lanes) {\n      if (lanes) {\n        this.options.lanes = lanes;\n      }\n      this._createGridSnapshot();\n      this.gridList.resizeGrid(this.options.lanes);\n      this._updateGridSnapshot();\n\n      this.reflow();\n    },\n\n    resizeItem: function(element, size) {\n      /**\n       * Resize an item.\n       *\n       * @param {Object} size\n       * @param {Number} [size.w]\n       * @param {Number} [size.h}\n       */\n\n      this._createGridSnapshot();\n      this.gridList.resizeItem(this._getItemByElement(element), size);\n      this._updateGridSnapshot();\n\n      this.render();\n    },\n\n    reflow: function() {\n      this._calculateCellSize();\n      this.render();\n    },\n\n    render: function() {\n      this._applySizeToItems();\n      this._applyPositionToItems();\n    },\n\n    _bindMethod: function(fn) {\n      /**\n       * Bind prototype method to instance scope (similar to CoffeeScript's fat\n       * arrow)\n       */\n      var that = this;\n      return function() {\n        return fn.apply(that, arguments);\n      };\n    },\n\n    _init: function() {\n      // Read items and their meta data. Ignore other list elements (like the\n      // position highlight)\n      this.$items = this.$element.children(this.options.itemSelector);\n      this.items = this._generateItemsFromDOM();\n      this._widestItem = Math.max.apply(\n        null, this.items.map(function(item) { return item.w; }));\n      this._tallestItem = Math.max.apply(\n        null, this.items.map(function(item) { return item.h; }));\n\n      // Used to highlight a position an element will land on upon drop\n      this.$positionHighlight = this.$element.find('.position-highlight').hide();\n\n      this._initGridList();\n      this.reflow();\n\n      if (this.options.dragAndDrop) {\n        // Init Draggable JQuery UI plugin for each of the list items\n        // http://api.jqueryui.com/draggable/\n        this.$items.draggable(this.draggableOptions);\n      }\n    },\n\n    _initGridList: function() {\n      // Create instance of GridList (decoupled lib for handling the grid\n      // positioning and sorting post-drag and dropping)\n      this.gridList = new GridList(this.items, {\n        lanes: this.options.lanes,\n        direction: this.options.direction\n      });\n    },\n\n    _bindEvents: function() {\n      this._onStart = this._bindMethod(this._onStart);\n      this._onDrag = this._bindMethod(this._onDrag);\n      this._onStop = this._bindMethod(this._onStop);\n      this.$items.on('dragstart', this._onStart);\n      this.$items.on('drag', this._onDrag);\n      this.$items.on('dragstop', this._onStop);\n    },\n\n    _unbindEvents: function() {\n      this.$items.off('dragstart', this._onStart);\n      this.$items.off('drag', this._onDrag);\n      this.$items.off('dragstop', this._onStop);\n    },\n\n    _onStart: function(event, ui) {\n      // Create a deep copy of the items; we use them to revert the item\n      // positions after each drag change, making an entire drag operation less\n      // distructable\n      this._createGridSnapshot();\n\n      // Since dragging actually alters the grid, we need to establish the number\n      // of cols (+1 extra) before the drag starts\n\n      this._maxGridCols = this.gridList.grid.length;\n    },\n\n    _onDrag: function(event, ui) {\n      var item = this._getItemByElement(ui.helper),\n          newPosition = this._snapItemPositionToGrid(item);\n\n      if (this._dragPositionChanged(newPosition)) {\n        this._previousDragPosition = newPosition;\n\n        // Regenerate the grid with the positions from when the drag started\n        GridList.cloneItems(this._items, this.items);\n        this.gridList.generateGrid();\n\n        // Since the items list is a deep copy, we need to fetch the item\n        // corresponding to this drag action again\n        item = this._getItemByElement(ui.helper);\n        this.gridList.moveItemToPosition(item, newPosition);\n\n        // Visually update item positions and highlight shape\n        this._applyPositionToItems();\n        this._highlightPositionForItem(item);\n      }\n    },\n\n    _onStop: function(event, ui) {\n      this._updateGridSnapshot();\n      this._previousDragPosition = null;\n\n      // HACK: jQuery.draggable removes this class after the dragstop callback,\n      // and we need it removed before the drop, to re-enable CSS transitions\n      $(ui.helper).removeClass('ui-draggable-dragging');\n\n      this._applyPositionToItems();\n      this._removePositionHighlight();\n    },\n\n    _generateItemsFromDOM: function() {\n      /**\n       * Generate the structure of items used by the GridList lib, using the DOM\n       * data of the children of the targeted element. The items will have an\n       * additional reference to the initial DOM element attached, in order to\n       * trace back to it and re-render it once its properties are changed by the\n       * GridList lib\n       */\n      var _this = this,\n          items = [],\n          item;\n      this.$items.each(function(i, element) {\n        items.push({\n          $element: $(element),\n          x: Number($(element).attr('data-x')),\n          y: Number($(element).attr('data-y')),\n          w: Number($(element).attr('data-w')),\n          h: Number($(element).attr('data-h')),\n          id: Number($(element).attr('data-id'))\n        });\n      });\n      return items;\n    },\n\n    _getItemByElement: function(element) {\n      // XXX: this could be optimized by storing the item reference inside the\n      // meta data of the DOM element\n      for (var i = 0; i < this.items.length; i++) {\n        if (this.items[i].$element.is(element)) {\n          return this.items[i];\n        }\n      }\n    },\n\n    _calculateCellSize: function() {\n      if (this.options.direction === \"horizontal\") {\n        this._cellHeight = Math.floor(this.$element.height() / this.options.lanes);\n        this._cellWidth = this._cellHeight * this.options.widthHeightRatio;\n      } else {\n        this._cellWidth = Math.floor(this.$element.width() / this.options.lanes);\n        this._cellHeight = this._cellWidth / this.options.widthHeightRatio;\n      }\n      if (this.options.heightToFontSizeRatio) {\n        this._fontSize = this._cellHeight * this.options.heightToFontSizeRatio;\n      }\n    },\n\n    _getItemWidth: function(item) {\n      return item.w * this._cellWidth;\n    },\n\n    _getItemHeight: function(item) {\n      return item.h * this._cellHeight;\n    },\n\n    _applySizeToItems: function() {\n      for (var i = 0; i < this.items.length; i++) {\n        this.items[i].$element.css({\n          width: this._getItemWidth(this.items[i]),\n          height: this._getItemHeight(this.items[i])\n        });\n      }\n      if (this.options.heightToFontSizeRatio) {\n        this.$items.css('font-size', this._fontSize);\n      }\n    },\n\n    _applyPositionToItems: function() {\n      // TODO: Implement group separators\n      for (var i = 0; i < this.items.length; i++) {\n        // Don't interfere with the positions of the dragged items\n        if (this.items[i].move) {\n          continue;\n        }\n        this.items[i].$element.css({\n          left: this.items[i].x * this._cellWidth,\n          top: this.items[i].y * this._cellHeight\n        });\n      }\n      // Update the width of the entire grid container with enough room on the\n      // right to allow dragging items to the end of the grid.\n      if (this.options.direction === \"horizontal\") {\n        this.$element.width(\n          (this.gridList.grid.length + this._widestItem) * this._cellWidth);\n      } else {\n        this.$element.height(\n          (this.gridList.grid.length + this._tallestItem) * this._cellHeight);\n      }\n    },\n\n    _dragPositionChanged: function(newPosition) {\n      if (!this._previousDragPosition) {\n        return true;\n      }\n      return (newPosition[0] != this._previousDragPosition[0] ||\n              newPosition[1] != this._previousDragPosition[1]);\n    },\n\n    _snapItemPositionToGrid: function(item) {\n      var position = item.$element.position();\n\n      position[0] -= this.$element.position().left;\n\n      var col = Math.round(position.left / this._cellWidth),\n          row = Math.round(position.top / this._cellHeight);\n\n      // Keep item position within the grid and don't let the item create more\n      // than one extra column\n      col = Math.max(col, 0);\n      row = Math.max(row, 0);\n\n      if (this.options.direction === \"horizontal\") {\n        col = Math.min(col, this._maxGridCols);\n        row = Math.min(row, this.options.lanes - item.h);\n      } else {\n        col = Math.min(col, this.options.lanes - item.w);\n        row = Math.min(row, this._maxGridCols);\n      }\n\n      return [col, row];\n    },\n\n    _highlightPositionForItem: function(item) {\n      this.$positionHighlight.css({\n        width: this._getItemWidth(item),\n        height: this._getItemHeight(item),\n        left: item.x * this._cellWidth,\n        top: item.y * this._cellHeight\n      }).show();\n      if (this.options.heightToFontSizeRatio) {\n        this.$positionHighlight.css('font-size', this._fontSize);\n      }\n    },\n\n    _removePositionHighlight: function() {\n      this.$positionHighlight.hide();\n    },\n\n    _createGridSnapshot: function() {\n      this._items = GridList.cloneItems(this.items);\n    },\n\n    _updateGridSnapshot: function() {\n      // Notify the user with the items that changed since the previous snapshot\n      this._triggerOnChange();\n      GridList.cloneItems(this.items, this._items);\n    },\n\n    _triggerOnChange: function() {\n      if (typeof(this.options.onChange) != 'function') {\n        return;\n      }\n      this.options.onChange.call(\n        this, this.gridList.getChangedItems(this._items, '$element'));\n    }\n  };\n\n  $.fn.gridList = function(options, draggableOptions) {\n    if (!window.GridList) {\n      throw new Error('GridList lib required');\n    }\n    var instance,\n        method,\n        args;\n    if (typeof(options) == 'string') {\n      method = options;\n      args =  Array.prototype.slice.call(arguments, 1);\n    }\n    this.each(function() {\n      instance = $(this).data('_gridList');\n      // The plugin call be called with no method on an existing GridList\n      // instance to re-initialize it\n      if (instance && !method) {\n        instance.destroy();\n        instance = null;\n      }\n      if (!instance) {\n        instance = new DraggableGridList(this, options, draggableOptions);\n        $(this).data('_gridList', instance);\n      }\n      if (method) {\n        instance[method].apply(instance, args);\n      }\n    });\n    // Maintain jQuery chain\n    return this;\n  };\n\n}));\n"]}