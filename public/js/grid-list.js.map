{"version":3,"sources":["fixtures.js","gridList.js","init.js","jquery.gridList.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"grid-list.js","sourcesContent":["// Class for easily creating grid elements\r\n// TODO: Add save (serialize) function to serialize all gridItems(with their pos) to a cookie\r\nclass GridItem {\r\n    constructor(width, height, x, y, image = null, link = null){\r\n        this.id = gridItems.length; // Make sure it has a unique id\r\n        this.width = width;\r\n        this.height = height;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.image = image;\r\n        this.link = link;\r\n        this.createHTML(link, image);\r\n\r\n        // Push this object to the gridItems list\r\n        gridItems.push(this);\r\n    }\r\n\r\n    createHTML(link = null, image = null){\r\n        this.html = $(\r\n            '<li data-id='+this.id+'>' +\r\n                '<div class=\"inner\">' +\r\n                    '<div class=\"controls\">' +\r\n                        '<a href=\"#zoom1\" class=\"edit\" data-a=\"resize\" data-w=\"1\" data-h=\"1\">1x1</a>' +\r\n                        '<a href=\"#zoom2\" class=\"edit\" data-a=\"resize\" data-w=\"2\" data-h=\"1\">2x1</a>' +\r\n                        '<a href=\"#zoom1\" class=\"edit\" data-a=\"resize\" data-w=\"1\" data-h=\"2\">1x2</a>' +\r\n                        '<a href=\"#zoom2\" class=\"edit\" data-a=\"resize\" data-w=\"2\" data-h=\"2\">2x2</a>' +\r\n                        '<a href=\"#edit\" class=\"edit\" data-a=\"edit\">edit</a>' +\r\n                    '</div>' +\r\n                    (link!==(null)?'<a href='+link+'>':'') +\r\n                        (image!==(null)?'<img src='+image+' class=\"image\">':'<div style=\"width:100%; height:100%; background-color: '+randomColor('rgb')+'\"></div>') +\r\n                    (link!==(null)?'</a>':'') +\r\n                '</div>' +\r\n            '</li>'\r\n        );\r\n    }\r\n\r\n    toJSON(){\r\n        return {\r\n            id: this.id,\r\n            width: this.width,\r\n            height: this.height,\r\n            x: this.x,\r\n            y: this.y,\r\n            image: this.image,\r\n            link: this.link,\r\n            // html: this.html\r\n        };\r\n    }\r\n}\r\n\r\nvar gridItems = [];\r\nvar fixtures = {};\r\n\r\nfixtures.GRID1 = [\r\n        new GridItem(1,1,0,0,\"https://www.nasa.gov/sites/default/files/styles/image_card_4x3_ratio/public/thumbnails/image/leisa_christmas_false_color.png?itok=Jxf0IlS4\", \"https://www.google.com\"),\r\n        new GridItem(1,2,1,0),\r\n        new GridItem(1,1,2,0),\r\n        new GridItem(1,1,3,0),\r\n        new GridItem(1,1,4,0),\r\n        new GridItem(1,1,0,1),\r\n        new GridItem(1,1,2,1),\r\n        new GridItem(1,1,3,1),\r\n    ];\r\n\r\n// Enable Node module\r\nif (typeof(require) == 'function') {\r\n    for (var k in fixtures) {\r\n        exports[k] = fixtures[k];\r\n    }\r\n}\r\n","(function (root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define([], factory);\r\n  } else if (typeof exports === 'object') {\r\n    // Node. Does not work with strict CommonJS, but\r\n    // only CommonJS-like environments that support module.exports,\r\n    // like Node.\r\n    module.exports = factory();\r\n  } else {\r\n    // Browser globals (root is window)\r\n    root.GridList = factory();\r\n  }\r\n}(this, function() {\r\n\r\nvar GridList = function(items, options) {\r\n  /**\r\n   * A GridList manages the two-dimensional positions from a list of items,\r\n   * within a virtual matrix.\r\n   *\r\n   * The GridList's main function is to convert the item positions from one\r\n   * grid size to another, maintaining as much of their order as possible.\r\n   *\r\n   * The GridList's second function is to handle collisions when moving an item\r\n   * over another.\r\n   *\r\n   * The positioning algorithm places items in columns. Starting from left to\r\n   * right, going through each column top to bottom.\r\n   *\r\n   * The size of an item is expressed using the number of cols and rows it\r\n   * takes up within the grid (w and h)\r\n   *\r\n   * The position of an item is express using the col and row position within\r\n   * the grid (x and y)\r\n   *\r\n   * An item is an object of structure:\r\n   * {\r\n   *   w: 3, h: 1,\r\n   *   x: 0, y: 1\r\n   * }\r\n   */\r\n\r\n  this._options = options;\r\n  for (var k in this.defaults) {\r\n    if (!this._options.hasOwnProperty(k)) {\r\n      this._options[k] = this.defaults[k];\r\n    }\r\n  }\r\n\r\n  this.items = items;\r\n\r\n  this._adjustSizeOfItems();\r\n\r\n  this.generateGrid();\r\n};\r\n\r\nGridList.cloneItems = function(items, _items) {\r\n  /**\r\n   * Clone items with a deep level of one. Items are not referenced but their\r\n   * properties are\r\n   */\r\n  var _item,\r\n      i,\r\n      k;\r\n  if (_items === undefined) {\r\n    _items = [];\r\n  }\r\n  for (i = 0; i < items.length; i++) {\r\n    // XXX: this is good because we don't want to lose item reference, but\r\n    // maybe we should clear their properties since some might be optional\r\n    if (!_items[i]) {\r\n      _items[i] = {};\r\n    }\r\n    for (k in items[i]) {\r\n      _items[i][k] = items[i][k];\r\n    }\r\n  }\r\n  return _items;\r\n};\r\n\r\nGridList.prototype = {\r\n\r\n  defaults: {\r\n    lanes: 5,\r\n    direction: 'horizontal'\r\n  },\r\n\r\n  /**\r\n   * Illustates grid as text-based table, using a number identifier for each\r\n   * item. E.g.\r\n   *\r\n   *  #|  0  1  2  3  4  5  6  7  8  9 10 11 12 13\r\n   *  --------------------------------------------\r\n   *  0| 00 02 03 04 04 06 08 08 08 12 12 13 14 16\r\n   *  1| 01 -- 03 05 05 07 09 10 11 11 -- 13 15 --\r\n   *\r\n   * Warn: Does not work if items don't have a width or height specified\r\n   * besides their position in the grid.\r\n   */\r\n  toString: function() {\r\n    var widthOfGrid = this.grid.length,\r\n        output = '\\n #|',\r\n        border = '\\n --',\r\n        item,\r\n        i,\r\n        j;\r\n\r\n    // Render the table header\r\n    for (i = 0; i < widthOfGrid; i++) {\r\n      output += ' ' + this._padNumber(i, ' ');\r\n      border += '---';\r\n    };\r\n    output += border;\r\n\r\n    // Render table contents row by row, as we go on the y axis\r\n    for (i = 0; i < this._options.lanes; i++) {\r\n      output += '\\n' + this._padNumber(i, ' ') + '|';\r\n      for (j = 0; j < widthOfGrid; j++) {\r\n        output += ' ';\r\n        item = this.grid[j][i];\r\n        output += item ? this._padNumber(this.items.indexOf(item), '0') : '--';\r\n      }\r\n    };\r\n    output += '\\n';\r\n    return output;\r\n  },\r\n\r\n  generateGrid: function() {\r\n    /**\r\n     * Build the grid structure from scratch, with the current item positions\r\n     */\r\n    var i;\r\n    this._resetGrid();\r\n    for (i = 0; i < this.items.length; i++) {\r\n      this._markItemPositionToGrid(this.items[i]);\r\n    }\r\n  },\r\n\r\n  resizeGrid: function(lanes) {\r\n    var currentColumn = 0;\r\n\r\n    this._options.lanes = lanes;\r\n    this._adjustSizeOfItems();\r\n\r\n    this._sortItemsByPosition();\r\n    this._resetGrid();\r\n\r\n    // The items will be sorted based on their index within the this.items array,\r\n    // that is their \"1d position\"\r\n    for (var i = 0; i < this.items.length; i++) {\r\n      var item = this.items[i],\r\n          position = this._getItemPosition(item);\r\n\r\n      this._updateItemPosition(\r\n        item, this.findPositionForItem(item, {x: currentColumn, y: 0}));\r\n\r\n      // New items should never be placed to the left of previous items\r\n      currentColumn = Math.max(currentColumn, position.x);\r\n    }\r\n\r\n    this._pullItemsToLeft();\r\n  },\r\n\r\n  findPositionForItem: function(item, start, fixedRow) {\r\n    /**\r\n     * This method has two options for the position we want for the item:\r\n     * - Starting from a certain row/column number and only looking for\r\n     *   positions to its right\r\n     * - Accepting positions for a certain row number only (use-case: items\r\n     *   being shifted to the left/right as a result of collisions)\r\n     *\r\n     * @param {Object<x:Number, y:Number, w:Number, h:Number} item\r\n     * @param {Object<x:Number, y:Number} start Position from which to start\r\n     *     the search.\r\n     * @param {Number} [fixedRow] If provided, we're going to try to find a\r\n     *     position for the new item on it. If doesn't fit there, we're going\r\n     *     to put it on the first row.\r\n     *\r\n     * @returns {Number[2]} x and y.\r\n     */\r\n\r\n    var x, y, position;\r\n\r\n    // Start searching for a position from the horizontal position of the\r\n    // rightmost item from the grid\r\n    for (x = start.x; x < this.grid.length; x++) {\r\n      if (fixedRow !== undefined) {\r\n        position = [x, fixedRow];\r\n\r\n        if (this._itemFitsAtPosition(item, position)) {\r\n          return position;\r\n        }\r\n      } else {\r\n        for (y = start.y; y < this._options.lanes; y++) {\r\n          position = [x, y];\r\n\r\n          if (this._itemFitsAtPosition(item, position)) {\r\n            return position;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // If we've reached this point, we need to start a new column\r\n    var newCol = this.grid.length,\r\n        newRow = 0;\r\n\r\n    if (fixedRow !== undefined &&\r\n        this._itemFitsAtPosition(item, [newCol, fixedRow])) {\r\n      newRow = fixedRow;\r\n    }\r\n\r\n    return [newCol, newRow];\r\n  },\r\n\r\n  moveItemToPosition: function(item, newPosition) {\r\n    var position = this._getItemPosition({\r\n      x: newPosition[0],\r\n      y: newPosition[1],\r\n      w: item.w,\r\n      h: item.h\r\n    });\r\n\r\n    this._updateItemPosition(item, [position.x, position.y]);\r\n    this._resolveCollisions(item);\r\n  },\r\n\r\n  resizeItem: function(item, size) {\r\n    /**\r\n     * Resize an item and resolve collisions.\r\n     *\r\n     * @param {Object} item A reference to an item that's part of the grid.\r\n     * @param {Object} size\r\n     * @param {Number} [size.w=item.w] The new width.\r\n     * @param {Number} [size.h=item.h] The new height.\r\n     */\r\n\r\n    var width = size.w || item.w,\r\n        height = size.h || item.h;\r\n\r\n    this._updateItemSize(item, width, height);\r\n\r\n    this._resolveCollisions(item);\r\n\r\n    this._pullItemsToLeft();\r\n  },\r\n\r\n  getChangedItems: function(initialItems, idAttribute) {\r\n    /**\r\n     * Compare the current items against a previous snapshot and return only\r\n     * the ones that changed their attributes in the meantime. This includes both\r\n     * position (x, y) and size (w, h)\r\n     *\r\n     * Since both their position and size can change, the items need an\r\n     * additional identifier attribute to match them with their previous state\r\n     */\r\n    var changedItems = [];\r\n\r\n    for (var i = 0; i < initialItems.length; i++) {\r\n      var item = this._getItemByAttribute(idAttribute,\r\n                                          initialItems[i][idAttribute]);\r\n\r\n      if (item.x !== initialItems[i].x ||\r\n          item.y !== initialItems[i].y ||\r\n          item.w !== initialItems[i].w ||\r\n          item.h !== initialItems[i].h) {\r\n        changedItems.push(item);\r\n      }\r\n    }\r\n\r\n    return changedItems;\r\n  },\r\n\r\n  _sortItemsByPosition: function() {\r\n    this.items.sort(function(item1, item2) {\r\n      var position1 = this._getItemPosition(item1),\r\n          position2 = this._getItemPosition(item2);\r\n\r\n      // Try to preserve columns.\r\n      if (position1.x != position2.x) {\r\n        return position1.x - position2.x;\r\n      }\r\n\r\n      if (position1.y != position2.y) {\r\n        return position1.y - position2.y;\r\n      }\r\n\r\n      // The items are placed on the same position.\r\n      return 0;\r\n    }.bind(this));\r\n  },\r\n\r\n  _adjustSizeOfItems: function() {\r\n    /**\r\n     * Some items can have 100% height or 100% width. Those dimmensions are\r\n     * expressed as 0. We need to ensure a valid width and height for each of\r\n     * those items as the number of items per lane.\r\n     */\r\n\r\n    for (var i = 0; i < this.items.length; i++) {\r\n      var item = this.items[i];\r\n\r\n      // This can happen only the first time items are checked.\r\n      // We need the property to have a value for all the items so that the\r\n      // `cloneItems` method will merge the properties properly. If we only set\r\n      // it to the items that need it then the following can happen:\r\n      //\r\n      // cloneItems([{id: 1, autoSize: true}, {id: 2}],\r\n      //            [{id: 2}, {id: 1, autoSize: true}]);\r\n      //\r\n      // will result in\r\n      //\r\n      // [{id: 1, autoSize: true}, {id: 2, autoSize: true}]\r\n      if (item.autoSize === undefined) {\r\n        item.autoSize = item.w === 0 || item.h === 0;\r\n      }\r\n\r\n      if (item.autoSize) {\r\n        if (this._options.direction === 'horizontal') {\r\n          item.h = this._options.lanes;\r\n        } else {\r\n          item.w = this._options.lanes;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _resetGrid: function() {\r\n    this.grid = [];\r\n  },\r\n\r\n  _itemFitsAtPosition: function(item, newPosition) {\r\n    /**\r\n     * Check that an item wouldn't overlap with another one if placed at a\r\n     * certain position within the grid\r\n     */\r\n\r\n    var position = this._getItemPosition(item),\r\n        x, y, row;\r\n\r\n    // No coordonate can be negative\r\n    if (newPosition[0] < 0 || newPosition[1] < 0) {\r\n      return false;\r\n    }\r\n\r\n    // Make sure the item isn't larger than the entire grid\r\n    if (newPosition[1] + position.h > this._options.lanes) {\r\n      return false;\r\n    }\r\n\r\n    // Make sure the position doesn't overlap with an already positioned\r\n    // item.\r\n    for (x = newPosition[0]; x < newPosition[0] + position.w; x++) {\r\n      var col = this.grid[x];\r\n\r\n      // Surely a column that hasn't even been created yet is available\r\n      if (!col) {\r\n        continue;\r\n      }\r\n\r\n      for (y = newPosition[1]; y < newPosition[1] + position.h; y++) {\r\n        // Any space occupied by an item can continue to be occupied by the\r\n        // same item.\r\n        if (col[y] && col[y] !== item) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  },\r\n\r\n  _updateItemPosition: function(item, position) {\r\n    if (item.x !== null && item.y !== null) {\r\n      this._deleteItemPositionFromGrid(item);\r\n    }\r\n\r\n    this._setItemPosition(item, position);\r\n\r\n    this._markItemPositionToGrid(item);\r\n  },\r\n\r\n  _updateItemSize: function(item, width, height) {\r\n    /**\r\n     * @param {Object} item A reference to a grid item.\r\n     * @param {Number} width The new width.\r\n     * @param {Number} height The new height.\r\n     */\r\n\r\n    if (item.x !== null && item.y !== null) {\r\n      this._deleteItemPositionFromGrid(item);\r\n    }\r\n\r\n    item.w = width;\r\n    item.h = height;\r\n\r\n    this._markItemPositionToGrid(item);\r\n  },\r\n\r\n  _markItemPositionToGrid: function(item) {\r\n    /**\r\n     * Mark the grid cells that are occupied by an item. This prevents items\r\n     * from overlapping in the grid\r\n     */\r\n\r\n    var position = this._getItemPosition(item),\r\n        x, y;\r\n\r\n    // Ensure that the grid has enough columns to accomodate the current item.\r\n    this._ensureColumns(position.x + position.w);\r\n\r\n    for (x = position.x; x < position.x + position.w; x++) {\r\n      for (y = position.y; y < position.y + position.h; y++) {\r\n        this.grid[x][y] = item;\r\n      }\r\n    }\r\n  },\r\n\r\n  _deleteItemPositionFromGrid: function(item) {\r\n    var position = this._getItemPosition(item),\r\n        x, y;\r\n\r\n    for (x = position.x; x < position.x + position.w; x++) {\r\n      // It can happen to try to remove an item from a position not generated\r\n      // in the grid, probably when loading a persisted grid of items. No need\r\n      // to create a column to be able to remove something from it, though\r\n      if (!this.grid[x]) {\r\n        continue;\r\n      }\r\n\r\n      for (y = position.y; y < position.y + position.h; y++) {\r\n        // Don't clear the cell if it's been occupied by a different widget in\r\n        // the meantime (e.g. when an item has been moved over this one, and\r\n        // thus by continuing to clear this item's previous position you would\r\n        // cancel the first item's move, leaving it without any position even)\r\n        if (this.grid[x][y] == item) {\r\n          this.grid[x][y] = null;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  _ensureColumns: function(N) {\r\n    /**\r\n     * Ensure that the grid has at least N columns available.\r\n     */\r\n    var i;\r\n    for (i = 0; i < N; i++) {\r\n      if (!this.grid[i]) {\r\n        this.grid.push(new GridCol(this._options.lanes));\r\n      }\r\n    }\r\n  },\r\n\r\n  _getItemsCollidingWithItem: function(item) {\r\n    var collidingItems = [];\r\n    for (var i = 0; i < this.items.length; i++) {\r\n      if (item != this.items[i] &&\r\n          this._itemsAreColliding(item, this.items[i])) {\r\n        collidingItems.push(i);\r\n      }\r\n    }\r\n    return collidingItems;\r\n  },\r\n\r\n  _itemsAreColliding: function(item1, item2) {\r\n    var position1 = this._getItemPosition(item1),\r\n        position2 = this._getItemPosition(item2);\r\n\r\n    return !(position2.x >= position1.x + position1.w ||\r\n             position2.x + position2.w <= position1.x ||\r\n             position2.y >= position1.y + position1.h ||\r\n             position2.y + position2.h <= position1.y);\r\n  },\r\n\r\n  _resolveCollisions: function(item) {\r\n    if (!this._tryToResolveCollisionsLocally(item)) {\r\n      this._pullItemsToLeft(item);\r\n    }\r\n    this._pullItemsToLeft();\r\n  },\r\n\r\n  _tryToResolveCollisionsLocally: function(item) {\r\n    /**\r\n     * Attempt to resolve the collisions after moving a an item over one or more\r\n     * other items within the grid, by shifting the position of the colliding\r\n     * items around the moving one. This might result in subsequent collisions,\r\n     * in which case we will revert all position permutations. To be able to\r\n     * revert to the initial item positions, we create a virtual grid in the\r\n     * process\r\n     */\r\n    var collidingItems = this._getItemsCollidingWithItem(item);\r\n    if (!collidingItems.length) {\r\n      return true;\r\n    }\r\n    var _gridList = new GridList([], this._options),\r\n        leftOfItem,\r\n        rightOfItem,\r\n        aboveOfItem,\r\n        belowOfItem;\r\n\r\n    GridList.cloneItems(this.items, _gridList.items);\r\n    _gridList.generateGrid();\r\n\r\n    for (var i = 0; i < collidingItems.length; i++) {\r\n      var collidingItem = _gridList.items[collidingItems[i]],\r\n          collidingPosition = this._getItemPosition(collidingItem);\r\n\r\n      // We use a simple algorithm for moving items around when collisions occur:\r\n      // In this prioritized order, we try to move a colliding item around the\r\n      // moving one:\r\n      // 1. to its left side\r\n      // 2. above it\r\n      // 3. under it\r\n      // 4. to its right side\r\n      var position = this._getItemPosition(item);\r\n\r\n      leftOfItem = [position.x - collidingPosition.w, collidingPosition.y];\r\n      rightOfItem = [position.x + position.w, collidingPosition.y];\r\n      aboveOfItem = [collidingPosition.x, position.y - collidingPosition.h];\r\n      belowOfItem = [collidingPosition.x, position.y + position.h];\r\n\r\n      if (_gridList._itemFitsAtPosition(collidingItem, leftOfItem)) {\r\n        _gridList._updateItemPosition(collidingItem, leftOfItem);\r\n      } else if (_gridList._itemFitsAtPosition(collidingItem, aboveOfItem)) {\r\n        _gridList._updateItemPosition(collidingItem, aboveOfItem);\r\n      } else if (_gridList._itemFitsAtPosition(collidingItem, belowOfItem)) {\r\n        _gridList._updateItemPosition(collidingItem, belowOfItem);\r\n      } else if (_gridList._itemFitsAtPosition(collidingItem, rightOfItem)) {\r\n        _gridList._updateItemPosition(collidingItem, rightOfItem);\r\n      } else {\r\n        // Collisions failed, we must use the pullItemsToLeft method to arrange\r\n        // the other items around this item with fixed position. This is our\r\n        // plan B for when local collision resolving fails.\r\n        return false;\r\n      }\r\n    }\r\n    // If we reached this point it means we managed to resolve the collisions\r\n    // from one single iteration, just by moving the colliding items around. So\r\n    // we accept this scenario and marge the brached-out grid instance into the\r\n    // original one\r\n    GridList.cloneItems(_gridList.items, this.items);\r\n    this.generateGrid();\r\n    return true;\r\n  },\r\n\r\n  _pullItemsToLeft: function(fixedItem) {\r\n    /**\r\n     * Build the grid from scratch, by using the current item positions and\r\n     * pulling them as much to the left as possible, removing as space between\r\n     * them as possible.\r\n     *\r\n     * If a \"fixed item\" is provided, its position will be kept intact and the\r\n     * rest of the items will be layed around it.\r\n     */\r\n\r\n\r\n    // Start a fresh grid with the fixed item already placed inside\r\n    this._sortItemsByPosition();\r\n    this._resetGrid();\r\n\r\n    // Start the grid with the fixed item as the first positioned item\r\n    if (fixedItem) {\r\n      var fixedPosition = this._getItemPosition(fixedItem);\r\n      this._updateItemPosition(fixedItem, [fixedPosition.x, fixedPosition.y]);\r\n    }\r\n\r\n    for (var i = 0; i < this.items.length; i++) {\r\n      var item = this.items[i],\r\n          position = this._getItemPosition(item);\r\n\r\n      // The fixed item keeps its exact position\r\n      if (fixedItem && item == fixedItem) {\r\n        continue;\r\n      }\r\n\r\n      var x = this._findLeftMostPositionForItem(item),\r\n          newPosition = this.findPositionForItem(\r\n            item, {x: x, y: 0}, position.y);\r\n\r\n      this._updateItemPosition(item, newPosition);\r\n    }\r\n  },\r\n\r\n  _findLeftMostPositionForItem: function(item) {\r\n    /**\r\n     * When pulling items to the left, we need to find the leftmost position for\r\n     * an item, with two considerations in mind:\r\n     * - preserving its current row\r\n     * - preserving the previous horizontal order between items\r\n     */\r\n\r\n    var tail = 0,\r\n        position = this._getItemPosition(item);\r\n\r\n    for (var i = 0; i < this.grid.length; i++) {\r\n      for (var j = position.y; j < position.y + position.h; j++) {\r\n        var otherItem = this.grid[i][j];\r\n\r\n        if (!otherItem) {\r\n          continue;\r\n        }\r\n\r\n        var otherPosition = this._getItemPosition(otherItem);\r\n\r\n        if (this.items.indexOf(otherItem) < this.items.indexOf(item)) {\r\n          tail = otherPosition.x + otherPosition.w;\r\n        }\r\n      }\r\n    }\r\n\r\n    return tail;\r\n  },\r\n\r\n  _getItemByAttribute: function(key, value) {\r\n    for (var i = 0; i < this.items.length; i++) {\r\n      if (this.items[i][key] === value) {\r\n        return this.items[i];\r\n      }\r\n    }\r\n    return null;\r\n  },\r\n\r\n  _padNumber: function(nr, prefix) {\r\n    // Currently works for 2-digit numbers (<100)\r\n    return nr >= 10 ? nr : prefix + nr;\r\n  },\r\n\r\n  _getItemPosition: function(item) {\r\n    /**\r\n     * If the direction is vertical we need to rotate the grid 90 deg to the\r\n     * left. Thus, we simulate the fact that items are being pulled to the top.\r\n     *\r\n     * Since the items have widths and heights, if we apply the classic\r\n     * counter-clockwise 90 deg rotation\r\n     *\r\n     *     [0 -1]\r\n     *     [1  0]\r\n     *\r\n     * then the top left point of an item will become the bottom left point of\r\n     * the rotated item. To adjust for this, we need to subtract from the y\r\n     * position the height of the original item - the width of the rotated item.\r\n     *\r\n     * However, if we do this then we'll reverse some actions: resizing the\r\n     * width of an item will stretch the item to the left instead of to the\r\n     * right; resizing an item that doesn't fit into the grid will push the\r\n     * items around it instead of going on a new row, etc.\r\n     *\r\n     * We found it better to do a vertical flip of the grid after rotating it.\r\n     * This restores the direction of the actions and greatly simplifies the\r\n     * transformations.\r\n     */\r\n\r\n    if (this._options.direction === 'horizontal') {\r\n      return item;\r\n    } else {\r\n      return {\r\n        x: item.y,\r\n        y: item.x,\r\n        w: item.h,\r\n        h: item.w\r\n      };\r\n    }\r\n  },\r\n\r\n  _setItemPosition: function(item, position) {\r\n    /**\r\n     * See _getItemPosition.\r\n     */\r\n\r\n    if (this._options.direction === 'horizontal') {\r\n      item.x = position[0];\r\n      item.y = position[1];\r\n    } else {\r\n      // We're supposed to subtract the rotated item's height which is actually\r\n      // the non-rotated item's width.\r\n      item.x = position[1];\r\n      item.y = position[0];\r\n    }\r\n  }\r\n};\r\n\r\nvar GridCol = function(lanes) {\r\n  for (var i = 0; i < lanes; i++) {\r\n    this.push(null);\r\n  }\r\n};\r\n\r\n// Extend the Array prototype\r\nGridCol.prototype = [];\r\n\r\n// This module will have direct access to the GridList class\r\nreturn GridList;\r\n\r\n}));\r\n","$(document).ready(function(){\r\n    createGrid(fixtures.GRID1);\r\n});\r\n\r\nvar Grid = {\r\n    currentSize: 4, // Amount of rows\r\n    buildElements: function($gridContainer, items) { // Create the items\r\n        var item, i;\r\n        for (i = 0; i < items.length; i++) {\r\n            item = items[i];\r\n            $item = item.html;\r\n            $item.attr({\r\n                'data-w': item.width,\r\n                'data-h': item.height,\r\n                'data-x': item.x,\r\n                'data-y': item.y\r\n            });\r\n            $gridContainer.append($item);\r\n        }\r\n    },\r\n    resize: function(size) {\r\n        if (size) {\r\n            this.currentSize = size;\r\n        }\r\n        $('#grid').gridList('resize', this.currentSize);\r\n    },\r\n    // flashItems: function(items) {\r\n    //     // Hack to flash changed items visually\r\n    //     for (var i = 0; i < items.length; i++) {\r\n    //         (function($element) {\r\n    //             $element.addClass('changed');\r\n    //             setTimeout(function() {\r\n    //                 $element.removeClass('changed');\r\n    //             }, 0);\r\n    //         })(items[i].$element);\r\n    //     }\r\n    // }\r\n};\r\n\r\n$(window).resize(function() {\r\n    $('#grid').gridList('reflow');\r\n});\r\n\r\nfunction createGrid(itemCollection) {\r\n    // Clear the grid\r\n    $(\"#grid\").empty();\r\n\r\n    // Build the items\r\n    Grid.buildElements($('#grid'), itemCollection);\r\n\r\n    // Convert the UL to a gridList\r\n    $('#grid').gridList({\r\n        lanes: Grid.currentSize,\r\n        widthHeightRatio: 264 / 294,\r\n        heightToFontSizeRatio: 0.25,\r\n        onChange: function(changedItems) {\r\n            // Save the new positions to the objects\r\n            $.each(changedItems, function(index, item){\r\n                var gridItem = gridItems[item.id];\r\n                gridItem.x = item.x;\r\n                gridItem.y = item.y;\r\n                gridItems[gridItem.id] = gridItem;\r\n            });\r\n\r\n            // Convert to JSON\r\n            // console.log(JSON.stringify(gridItems));\r\n            // TODO: Save the JSON string to a cookie\r\n            var grid = JSON.stringify(gridItems);\r\n\r\n            // var date_obj = new Date();\r\n            // date_obj.setMonth(date_obj.getMonth() + 1); // Define lifetime of the cookie;\r\n            // var exp_date = date_obj.toUTCString();//.setMonth(new Date().getMonth() + 1);//.toUTCString();\r\n\r\n            // TODO: Call CookieController to create a cookie\r\n            // document.cookie = \"grid=\"+grid+\"; expires=\"+exp_date+\";\";\r\n            var sendData = {\r\n                _token: window.Laravel.csrfToken,\r\n                name: 'grid_layout',\r\n                value: grid\r\n            };\r\n            $.post(\"/api/v1/cookies\", sendData, function(data){\r\n                console.log(\"Cookie saved!\");\r\n\r\n                $.get(\"/api/v1/cookies/grid_layout\", function (data) {\r\n                    console.log(data);\r\n\r\n                    sendData._method = \"delete\";\r\n                    $.post(\"/api/v1/cookies/grid_layout\", sendData, function(data){\r\n                        console.log(\"Cookie deleted!\");\r\n\r\n                        $.get(\"/api/v1/cookies/grid_layout\", function (data) {\r\n                            console.log(data);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        }\r\n    });\r\n\r\n    // Eventhandler for the control buttons\r\n    $('#grid li .edit').click(function(e) {\r\n        e.preventDefault();\r\n        var itemElement = $(e.currentTarget).closest('li');\r\n        var gridItem = gridItems[itemElement.data('id')];\r\n        var itemAction = $(e.currentTarget).data('a');\r\n\r\n        if(itemAction == 'resize')\r\n        {\r\n            // Resize grid item according to given data\r\n            $('#grid').gridList('resizeItem', itemElement, {\r\n                w: $(e.currentTarget).data('w'),\r\n                h: $(e.currentTarget).data('h')\r\n            });\r\n\r\n            // Save the changes to the object\r\n            gridItem.width = $(e.currentTarget).data('w');\r\n            gridItem.height = $(e.currentTarget).data('h');\r\n            // gridItem.createHTML();\r\n            gridItems[gridItem.id] = gridItem;\r\n        }\r\n        else if(itemAction == 'edit')\r\n        {\r\n            // Open modal to edit the grid items properties\r\n            $(\"#edit_id\").val(gridItem.id);\r\n            $(\"#edit_link\").val(gridItem.link!==(null)?gridItem.link:'');\r\n            $(\"#edit_image\").val(gridItem.image!==(null)?gridItem.image:'');\r\n            $(\"#modal_edit\").modal('show');\r\n        }\r\n    });\r\n\r\n    // Eventhandler for saving edit modal\r\n    $('#edit_save').on('click', function(e){\r\n        // Update grid item and refresh the grid\r\n        // TODO: Expand Form validation\r\n        // TODO: Improve performance\r\n        var gridItem = gridItems[$(\"#edit_id\").val()];\r\n        var link = null, image = null;\r\n        if($(\"#edit_link\").val() != '')\r\n            link = $(\"#edit_link\").val(); // TODO: Check if we need to add 'http' prefix? Otherwise laravel returns an error...\r\n        if($(\"#edit_image\").val() != '')\r\n            image = $(\"#edit_image\").val();\r\n        gridItem.createHTML(link, image);\r\n        gridItems[gridItem.id] = gridItem;\r\n\r\n        // Recreate the grid\r\n        createGrid(gridItems);\r\n\r\n        // Hide the modal\r\n        $(\"#modal_edit\").modal('hide');\r\n    });\r\n\r\n    //// Adds a row to the grid\r\n    // $('.add-row').click(function(e) {\r\n    //     e.preventDefault();\r\n    //     Grid.resize(Grid.currentSize + 1);\r\n    // });\r\n\r\n    //// Removes a row from the grid\r\n    // $('.remove-row').click(function(e) {\r\n    //     e.preventDefault();\r\n    //     Grid.resize(Math.max(1, Grid.currentSize - 1));\r\n    // });\r\n};","// It does not try to register in a CommonJS environment since jQuery is not\r\n// likely to run in those environments.\r\n(function (factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define(['jquery', 'gridlist'], factory);\r\n  } else {\r\n    factory(jQuery, GridList);\r\n  }\r\n}(function($, GridList) {\r\n\r\n  var DraggableGridList = function(element, options, draggableOptions) {\r\n    this.options = $.extend({}, this.defaults, options);\r\n    this.draggableOptions = $.extend(\r\n      {}, this.draggableDefaults, draggableOptions);\r\n\r\n    this.$element = $(element);\r\n    this._init();\r\n    this._bindEvents();\r\n  };\r\n\r\n  DraggableGridList.prototype = {\r\n\r\n    defaults: {\r\n      lanes: 5,\r\n      direction: \"horizontal\",\r\n      itemSelector: 'li[data-w]',\r\n      widthHeightRatio: 1,\r\n      dragAndDrop: true\r\n    },\r\n\r\n    draggableDefaults: {\r\n      zIndex: 2,\r\n      scroll: false,\r\n      containment: \"parent\"\r\n    },\r\n\r\n    destroy: function() {\r\n      this._unbindEvents();\r\n    },\r\n\r\n    resize: function(lanes) {\r\n      if (lanes) {\r\n        this.options.lanes = lanes;\r\n      }\r\n      this._createGridSnapshot();\r\n      this.gridList.resizeGrid(this.options.lanes);\r\n      this._updateGridSnapshot();\r\n\r\n      this.reflow();\r\n    },\r\n\r\n    resizeItem: function(element, size) {\r\n      /**\r\n       * Resize an item.\r\n       *\r\n       * @param {Object} size\r\n       * @param {Number} [size.w]\r\n       * @param {Number} [size.h}\r\n       */\r\n\r\n      this._createGridSnapshot();\r\n      this.gridList.resizeItem(this._getItemByElement(element), size);\r\n      this._updateGridSnapshot();\r\n\r\n      this.render();\r\n    },\r\n\r\n    reflow: function() {\r\n      this._calculateCellSize();\r\n      this.render();\r\n    },\r\n\r\n    render: function() {\r\n      this._applySizeToItems();\r\n      this._applyPositionToItems();\r\n    },\r\n\r\n    _bindMethod: function(fn) {\r\n      /**\r\n       * Bind prototype method to instance scope (similar to CoffeeScript's fat\r\n       * arrow)\r\n       */\r\n      var that = this;\r\n      return function() {\r\n        return fn.apply(that, arguments);\r\n      };\r\n    },\r\n\r\n    _init: function() {\r\n      // Read items and their meta data. Ignore other list elements (like the\r\n      // position highlight)\r\n      this.$items = this.$element.children(this.options.itemSelector);\r\n      this.items = this._generateItemsFromDOM();\r\n      this._widestItem = Math.max.apply(\r\n        null, this.items.map(function(item) { return item.w; }));\r\n      this._tallestItem = Math.max.apply(\r\n        null, this.items.map(function(item) { return item.h; }));\r\n\r\n      // Used to highlight a position an element will land on upon drop\r\n      this.$positionHighlight = this.$element.find('.position-highlight').hide();\r\n\r\n      this._initGridList();\r\n      this.reflow();\r\n\r\n      if (this.options.dragAndDrop) {\r\n        // Init Draggable JQuery UI plugin for each of the list items\r\n        // http://api.jqueryui.com/draggable/\r\n        this.$items.draggable(this.draggableOptions);\r\n      }\r\n    },\r\n\r\n    _initGridList: function() {\r\n      // Create instance of GridList (decoupled lib for handling the grid\r\n      // positioning and sorting post-drag and dropping)\r\n      this.gridList = new GridList(this.items, {\r\n        lanes: this.options.lanes,\r\n        direction: this.options.direction\r\n      });\r\n    },\r\n\r\n    _bindEvents: function() {\r\n      this._onStart = this._bindMethod(this._onStart);\r\n      this._onDrag = this._bindMethod(this._onDrag);\r\n      this._onStop = this._bindMethod(this._onStop);\r\n      this.$items.on('dragstart', this._onStart);\r\n      this.$items.on('drag', this._onDrag);\r\n      this.$items.on('dragstop', this._onStop);\r\n    },\r\n\r\n    _unbindEvents: function() {\r\n      this.$items.off('dragstart', this._onStart);\r\n      this.$items.off('drag', this._onDrag);\r\n      this.$items.off('dragstop', this._onStop);\r\n    },\r\n\r\n    _onStart: function(event, ui) {\r\n      // Create a deep copy of the items; we use them to revert the item\r\n      // positions after each drag change, making an entire drag operation less\r\n      // distructable\r\n      this._createGridSnapshot();\r\n\r\n      // Since dragging actually alters the grid, we need to establish the number\r\n      // of cols (+1 extra) before the drag starts\r\n\r\n      this._maxGridCols = this.gridList.grid.length;\r\n    },\r\n\r\n    _onDrag: function(event, ui) {\r\n      var item = this._getItemByElement(ui.helper),\r\n          newPosition = this._snapItemPositionToGrid(item);\r\n\r\n      if (this._dragPositionChanged(newPosition)) {\r\n        this._previousDragPosition = newPosition;\r\n\r\n        // Regenerate the grid with the positions from when the drag started\r\n        GridList.cloneItems(this._items, this.items);\r\n        this.gridList.generateGrid();\r\n\r\n        // Since the items list is a deep copy, we need to fetch the item\r\n        // corresponding to this drag action again\r\n        item = this._getItemByElement(ui.helper);\r\n        this.gridList.moveItemToPosition(item, newPosition);\r\n\r\n        // Visually update item positions and highlight shape\r\n        this._applyPositionToItems();\r\n        this._highlightPositionForItem(item);\r\n      }\r\n    },\r\n\r\n    _onStop: function(event, ui) {\r\n      this._updateGridSnapshot();\r\n      this._previousDragPosition = null;\r\n\r\n      // HACK: jQuery.draggable removes this class after the dragstop callback,\r\n      // and we need it removed before the drop, to re-enable CSS transitions\r\n      $(ui.helper).removeClass('ui-draggable-dragging');\r\n\r\n      this._applyPositionToItems();\r\n      this._removePositionHighlight();\r\n    },\r\n\r\n    _generateItemsFromDOM: function() {\r\n      /**\r\n       * Generate the structure of items used by the GridList lib, using the DOM\r\n       * data of the children of the targeted element. The items will have an\r\n       * additional reference to the initial DOM element attached, in order to\r\n       * trace back to it and re-render it once its properties are changed by the\r\n       * GridList lib\r\n       */\r\n      var _this = this,\r\n          items = [],\r\n          item;\r\n      this.$items.each(function(i, element) {\r\n        items.push({\r\n          $element: $(element),\r\n          x: Number($(element).attr('data-x')),\r\n          y: Number($(element).attr('data-y')),\r\n          w: Number($(element).attr('data-w')),\r\n          h: Number($(element).attr('data-h')),\r\n          id: Number($(element).attr('data-id'))\r\n        });\r\n      });\r\n      return items;\r\n    },\r\n\r\n    _getItemByElement: function(element) {\r\n      // XXX: this could be optimized by storing the item reference inside the\r\n      // meta data of the DOM element\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        if (this.items[i].$element.is(element)) {\r\n          return this.items[i];\r\n        }\r\n      }\r\n    },\r\n\r\n    _calculateCellSize: function() {\r\n      if (this.options.direction === \"horizontal\") {\r\n        this._cellHeight = Math.floor(this.$element.height() / this.options.lanes);\r\n        this._cellWidth = this._cellHeight * this.options.widthHeightRatio;\r\n      } else {\r\n        this._cellWidth = Math.floor(this.$element.width() / this.options.lanes);\r\n        this._cellHeight = this._cellWidth / this.options.widthHeightRatio;\r\n      }\r\n      if (this.options.heightToFontSizeRatio) {\r\n        this._fontSize = this._cellHeight * this.options.heightToFontSizeRatio;\r\n      }\r\n    },\r\n\r\n    _getItemWidth: function(item) {\r\n      return item.w * this._cellWidth;\r\n    },\r\n\r\n    _getItemHeight: function(item) {\r\n      return item.h * this._cellHeight;\r\n    },\r\n\r\n    _applySizeToItems: function() {\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        this.items[i].$element.css({\r\n          width: this._getItemWidth(this.items[i]),\r\n          height: this._getItemHeight(this.items[i])\r\n        });\r\n      }\r\n      if (this.options.heightToFontSizeRatio) {\r\n        this.$items.css('font-size', this._fontSize);\r\n      }\r\n    },\r\n\r\n    _applyPositionToItems: function() {\r\n      // TODO: Implement group separators\r\n      for (var i = 0; i < this.items.length; i++) {\r\n        // Don't interfere with the positions of the dragged items\r\n        if (this.items[i].move) {\r\n          continue;\r\n        }\r\n        this.items[i].$element.css({\r\n          left: this.items[i].x * this._cellWidth,\r\n          top: this.items[i].y * this._cellHeight\r\n        });\r\n      }\r\n      // Update the width of the entire grid container with enough room on the\r\n      // right to allow dragging items to the end of the grid.\r\n      if (this.options.direction === \"horizontal\") {\r\n        this.$element.width(\r\n          (this.gridList.grid.length + this._widestItem) * this._cellWidth);\r\n      } else {\r\n        this.$element.height(\r\n          (this.gridList.grid.length + this._tallestItem) * this._cellHeight);\r\n      }\r\n    },\r\n\r\n    _dragPositionChanged: function(newPosition) {\r\n      if (!this._previousDragPosition) {\r\n        return true;\r\n      }\r\n      return (newPosition[0] != this._previousDragPosition[0] ||\r\n              newPosition[1] != this._previousDragPosition[1]);\r\n    },\r\n\r\n    _snapItemPositionToGrid: function(item) {\r\n      var position = item.$element.position();\r\n\r\n      position[0] -= this.$element.position().left;\r\n\r\n      var col = Math.round(position.left / this._cellWidth),\r\n          row = Math.round(position.top / this._cellHeight);\r\n\r\n      // Keep item position within the grid and don't let the item create more\r\n      // than one extra column\r\n      col = Math.max(col, 0);\r\n      row = Math.max(row, 0);\r\n\r\n      if (this.options.direction === \"horizontal\") {\r\n        col = Math.min(col, this._maxGridCols);\r\n        row = Math.min(row, this.options.lanes - item.h);\r\n      } else {\r\n        col = Math.min(col, this.options.lanes - item.w);\r\n        row = Math.min(row, this._maxGridCols);\r\n      }\r\n\r\n      return [col, row];\r\n    },\r\n\r\n    _highlightPositionForItem: function(item) {\r\n      this.$positionHighlight.css({\r\n        width: this._getItemWidth(item),\r\n        height: this._getItemHeight(item),\r\n        left: item.x * this._cellWidth,\r\n        top: item.y * this._cellHeight\r\n      }).show();\r\n      if (this.options.heightToFontSizeRatio) {\r\n        this.$positionHighlight.css('font-size', this._fontSize);\r\n      }\r\n    },\r\n\r\n    _removePositionHighlight: function() {\r\n      this.$positionHighlight.hide();\r\n    },\r\n\r\n    _createGridSnapshot: function() {\r\n      this._items = GridList.cloneItems(this.items);\r\n    },\r\n\r\n    _updateGridSnapshot: function() {\r\n      // Notify the user with the items that changed since the previous snapshot\r\n      this._triggerOnChange();\r\n      GridList.cloneItems(this.items, this._items);\r\n    },\r\n\r\n    _triggerOnChange: function() {\r\n      if (typeof(this.options.onChange) != 'function') {\r\n        return;\r\n      }\r\n      this.options.onChange.call(\r\n        this, this.gridList.getChangedItems(this._items, '$element'));\r\n    }\r\n  };\r\n\r\n  $.fn.gridList = function(options, draggableOptions) {\r\n    if (!window.GridList) {\r\n      throw new Error('GridList lib required');\r\n    }\r\n    var instance,\r\n        method,\r\n        args;\r\n    if (typeof(options) == 'string') {\r\n      method = options;\r\n      args =  Array.prototype.slice.call(arguments, 1);\r\n    }\r\n    this.each(function() {\r\n      instance = $(this).data('_gridList');\r\n      // The plugin call be called with no method on an existing GridList\r\n      // instance to re-initialize it\r\n      if (instance && !method) {\r\n        instance.destroy();\r\n        instance = null;\r\n      }\r\n      if (!instance) {\r\n        instance = new DraggableGridList(this, options, draggableOptions);\r\n        $(this).data('_gridList', instance);\r\n      }\r\n      if (method) {\r\n        instance[method].apply(instance, args);\r\n      }\r\n    });\r\n    // Maintain jQuery chain\r\n    return this;\r\n  };\r\n\r\n}));\r\n"]}