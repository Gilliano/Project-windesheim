{"version":3,"sources":["jquery.contextMenu.js","jquery.ui.position.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC18DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"contextmenu.js","sourcesContent":["/*!\n * jQuery contextMenu v2.4.1 - Plugin for simple contextMenu handling\n *\n * Version: v2.4.1\n *\n * Authors: Bj√∂rn Brala (SWIS.nl), Rodney Rehm, Addy Osmani (patches for FF)\n * Web: http://swisnl.github.io/jQuery-contextMenu/\n *\n * Copyright (c) 2011-2016 SWIS BV and contributors\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *   GPL v3 http://opensource.org/licenses/GPL-3.0\n *\n * Date: 2016-12-09T17:38:42.564Z\n */\n\n(function (factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as anonymous module.\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        // Node / CommonJS\n        factory(require('jquery'));\n    } else {\n        // Browser globals.\n        factory(jQuery);\n    }\n})(function ($) {\n\n    'use strict';\n\n    // TODO: -\n    // ARIA stuff: menuitem, menuitemcheckbox und menuitemradio\n    // create <menu> structure if $.support[htmlCommand || htmlMenuitem] and !opt.disableNative\n\n    // determine html5 compatibility\n    $.support.htmlMenuitem = ('HTMLMenuItemElement' in window);\n    $.support.htmlCommand = ('HTMLCommandElement' in window);\n    $.support.eventSelectstart = ('onselectstart' in document.documentElement);\n    /* // should the need arise, test for css user-select\n     $.support.cssUserSelect = (function(){\n     var t = false,\n     e = document.createElement('div');\n\n     $.each('Moz|Webkit|Khtml|O|ms|Icab|'.split('|'), function(i, prefix) {\n     var propCC = prefix + (prefix ? 'U' : 'u') + 'serSelect',\n     prop = (prefix ? ('-' + prefix.toLowerCase() + '-') : '') + 'user-select';\n\n     e.style.cssText = prop + ': text;';\n     if (e.style[propCC] == 'text') {\n     t = true;\n     return false;\n     }\n\n     return true;\n     });\n\n     return t;\n     })();\n     */\n\n    /* jshint ignore:start */\n    if (!$.ui || !$.widget) {\n        // duck punch $.cleanData like jQueryUI does to get that remove event\n        $.cleanData = (function (orig) {\n            return function (elems) {\n                var events, elem, i;\n                for (i = 0; elems[i] != null; i++) {\n                    elem = elems[i];\n                    try {\n                        // Only trigger remove when necessary to save time\n                        events = $._data(elem, 'events');\n                        if (events && events.remove) {\n                            $(elem).triggerHandler('remove');\n                        }\n\n                        // Http://bugs.jquery.com/ticket/8235\n                    } catch (e) {}\n                }\n                orig(elems);\n            };\n        })($.cleanData);\n    }\n    /* jshint ignore:end */\n\n    var // currently active contextMenu trigger\n        $currentTrigger = null,\n    // is contextMenu initialized with at least one menu?\n        initialized = false,\n    // window handle\n        $win = $(window),\n    // number of registered menus\n        counter = 0,\n    // mapping selector to namespace\n        namespaces = {},\n    // mapping namespace to options\n        menus = {},\n    // custom command type handlers\n        types = {},\n    // default values\n        defaults = {\n            // selector of contextMenu trigger\n            selector: null,\n            // where to append the menu to\n            appendTo: null,\n            // method to trigger context menu [\"right\", \"left\", \"hover\"]\n            trigger: 'right',\n            // hide menu when mouse leaves trigger / menu elements\n            autoHide: false,\n            // ms to wait before showing a hover-triggered context menu\n            delay: 200,\n            // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu\n            // as long as the trigger happened on one of the trigger-element's child nodes\n            reposition: true,\n\t        //ability to select submenu\n\t        selectableSubMenu: false,\n            \n            // Default classname configuration to be able avoid conflicts in frameworks\n            classNames : {\n                hover: 'context-menu-hover', // Item hover\n                disabled: 'context-menu-disabled', // Item disabled\n                visible: 'context-menu-visible', // Item visible\n                notSelectable: 'context-menu-not-selectable', // Item not selectable\n\n                icon: 'context-menu-icon',\n                iconEdit: 'context-menu-icon-edit',\n                iconCut: 'context-menu-icon-cut',\n                iconCopy: 'context-menu-icon-copy',\n                iconPaste: 'context-menu-icon-paste',\n                iconDelete: 'context-menu-icon-delete',\n                iconAdd: 'context-menu-icon-add',\n                iconQuit: 'context-menu-icon-quit',\n                iconLoadingClass: 'context-menu-icon-loading'\n            },\n\n            // determine position to show menu at\n            determinePosition: function ($menu) {\n                // position to the lower middle of the trigger element\n                if ($.ui && $.ui.position) {\n                    // .position() is provided as a jQuery UI utility\n                    // (...and it won't work on hidden elements)\n                    $menu.css('display', 'block').position({\n                        my: 'center top',\n                        at: 'center bottom',\n                        of: this,\n                        offset: '0 5',\n                        collision: 'fit'\n                    }).css('display', 'none');\n                } else {\n                    // determine contextMenu position\n                    var offset = this.offset();\n                    offset.top += this.outerHeight();\n                    offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;\n                    $menu.css(offset);\n                }\n            },\n            // position menu\n            position: function (opt, x, y) {\n                var offset;\n                // determine contextMenu position\n                if (!x && !y) {\n                    opt.determinePosition.call(this, opt.$menu);\n                    return;\n                } else if (x === 'maintain' && y === 'maintain') {\n                    // x and y must not be changed (after re-show on command click)\n                    offset = opt.$menu.position();\n                } else {\n                    // x and y are given (by mouse event)\n                    offset = {top: y, left: x};\n                }\n\n                // correct offset if viewport demands it\n                var bottom = $win.scrollTop() + $win.height(),\n                    right = $win.scrollLeft() + $win.width(),\n                    height = opt.$menu.outerHeight(),\n                    width = opt.$menu.outerWidth();\n\n                if (offset.top + height > bottom) {\n                    offset.top -= height;\n                }\n\n                if (offset.top < 0) {\n                    offset.top = 0;\n                }\n\n                if (offset.left + width > right) {\n                    offset.left -= width;\n                }\n\n                if (offset.left < 0) {\n                    offset.left = 0;\n                }\n\n                opt.$menu.css(offset);\n            },\n            // position the sub-menu\n            positionSubmenu: function ($menu) {\n                if ($menu === undefined) {\n                    // When user hovers over item (which has sub items) handle.focusItem will call this.\n                    // but the submenu does not exist yet if opt.items is a promise. just return, will\n                    // call positionSubmenu after promise is completed.\n                    return;\n                }\n                if ($.ui && $.ui.position) {\n                    // .position() is provided as a jQuery UI utility\n                    // (...and it won't work on hidden elements)\n                    $menu.css('display', 'block').position({\n                        my: 'left top',\n                        at: 'right top',\n                        of: this,\n                        collision: 'flipfit fit'\n                    }).css('display', '');\n                } else {\n                    // determine contextMenu position\n                    var offset = {\n                        top: 0,\n                        left: this.outerWidth()\n                    };\n                    $menu.css(offset);\n                }\n            },\n            // offset to add to zIndex\n            zIndex: 1,\n            // show hide animation settings\n            animation: {\n                duration: 50,\n                show: 'slideDown',\n                hide: 'slideUp'\n            },\n            // events\n            events: {\n                show: $.noop,\n                hide: $.noop\n            },\n            // default callback\n            callback: null,\n            // list of contextMenu items\n            items: {}\n        },\n    // mouse position for hover activation\n        hoveract = {\n            timer: null,\n            pageX: null,\n            pageY: null\n        },\n    // determine zIndex\n        zindex = function ($t) {\n            var zin = 0,\n                $tt = $t;\n\n            while (true) {\n                zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0);\n                $tt = $tt.parent();\n                if (!$tt || !$tt.length || 'html body'.indexOf($tt.prop('nodeName').toLowerCase()) > -1) {\n                    break;\n                }\n            }\n            return zin;\n        },\n    // event handlers\n        handle = {\n            // abort anything\n            abortevent: function (e) {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n            },\n            // contextmenu show dispatcher\n            contextmenu: function (e) {\n                var $this = $(this);\n\n                // disable actual context-menu if we are using the right mouse button as the trigger\n                if (e.data.trigger === 'right') {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                }\n\n                // abort native-triggered events unless we're triggering on right click\n                if ((e.data.trigger !== 'right' && e.data.trigger !== 'demand') && e.originalEvent) {\n                    return;\n                }\n\n                // Let the current contextmenu decide if it should show or not based on its own trigger settings\n                if (e.mouseButton !== undefined && e.data) {\n                    if (!(e.data.trigger === 'left' && e.mouseButton === 0) && !(e.data.trigger === 'right' && e.mouseButton === 2)) {\n                        // Mouse click is not valid.\n                        return;\n                    }\n                }\n\n                // abort event if menu is visible for this trigger\n                if ($this.hasClass('context-menu-active')) {\n                    return;\n                }\n\n                if (!$this.hasClass('context-menu-disabled')) {\n                    // theoretically need to fire a show event at <menu>\n                    // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus\n                    // var evt = jQuery.Event(\"show\", { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this });\n                    // e.data.$menu.trigger(evt);\n\n                    $currentTrigger = $this;\n                    if (e.data.build) {\n                        var built = e.data.build($currentTrigger, e);\n                        // abort if build() returned false\n                        if (built === false) {\n                            return;\n                        }\n\n                        // dynamically build menu on invocation\n                        e.data = $.extend(true, {}, defaults, e.data, built || {});\n\n                        // abort if there are no items to display\n                        if (!e.data.items || $.isEmptyObject(e.data.items)) {\n                            // Note: jQuery captures and ignores errors from event handlers\n                            if (window.console) {\n                                (console.error || console.log).call(console, 'No items specified to show in contextMenu');\n                            }\n\n                            throw new Error('No Items specified');\n                        }\n\n                        // backreference for custom command type creation\n                        e.data.$trigger = $currentTrigger;\n\n                        op.create(e.data);\n                    }\n                    var showMenu = false;\n                    for (var item in e.data.items) {\n                        if (e.data.items.hasOwnProperty(item)) {\n                            var visible;\n                            if ($.isFunction(e.data.items[item].visible)) {\n                                visible = e.data.items[item].visible.call($(e.currentTarget), item, e.data);\n                            } else if (typeof e.data.items[item] !== 'undefined' && e.data.items[item].visible) {\n                                visible = e.data.items[item].visible === true;\n                            } else {\n                                visible = true;\n                            }\n                            if (visible) {\n                                showMenu = true;\n                            }\n                        }\n                    }\n                    if (showMenu) {\n                        // show menu\n                        op.show.call($this, e.data, e.pageX, e.pageY);\n                    }\n                }\n            },\n            // contextMenu left-click trigger\n            click: function (e) {\n                e.preventDefault();\n                e.stopImmediatePropagation();\n                $(this).trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY}));\n            },\n            // contextMenu right-click trigger\n            mousedown: function (e) {\n                // register mouse down\n                var $this = $(this);\n\n                // hide any previous menus\n                if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {\n                    $currentTrigger.data('contextMenu').$menu.trigger('contextmenu:hide');\n                }\n\n                // activate on right click\n                if (e.button === 2) {\n                    $currentTrigger = $this.data('contextMenuActive', true);\n                }\n            },\n            // contextMenu right-click trigger\n            mouseup: function (e) {\n                // show menu\n                var $this = $(this);\n                if ($this.data('contextMenuActive') && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass('context-menu-disabled')) {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    $currentTrigger = $this;\n                    $this.trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY}));\n                }\n\n                $this.removeData('contextMenuActive');\n            },\n            // contextMenu hover trigger\n            mouseenter: function (e) {\n                var $this = $(this),\n                    $related = $(e.relatedTarget),\n                    $document = $(document);\n\n                // abort if we're coming from a menu\n                if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {\n                    return;\n                }\n\n                // abort if a menu is shown\n                if ($currentTrigger && $currentTrigger.length) {\n                    return;\n                }\n\n                hoveract.pageX = e.pageX;\n                hoveract.pageY = e.pageY;\n                hoveract.data = e.data;\n                $document.on('mousemove.contextMenuShow', handle.mousemove);\n                hoveract.timer = setTimeout(function () {\n                    hoveract.timer = null;\n                    $document.off('mousemove.contextMenuShow');\n                    $currentTrigger = $this;\n                    $this.trigger($.Event('contextmenu', {\n                        data: hoveract.data,\n                        pageX: hoveract.pageX,\n                        pageY: hoveract.pageY\n                    }));\n                }, e.data.delay);\n            },\n            // contextMenu hover trigger\n            mousemove: function (e) {\n                hoveract.pageX = e.pageX;\n                hoveract.pageY = e.pageY;\n            },\n            // contextMenu hover trigger\n            mouseleave: function (e) {\n                // abort if we're leaving for a menu\n                var $related = $(e.relatedTarget);\n                if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {\n                    return;\n                }\n\n                try {\n                    clearTimeout(hoveract.timer);\n                } catch (e) {\n                }\n\n                hoveract.timer = null;\n            },\n            // click on layer to hide contextMenu\n            layerClick: function (e) {\n                var $this = $(this),\n                    root = $this.data('contextMenuRoot'),\n                    button = e.button,\n                    x = e.pageX,\n                    y = e.pageY,\n                    target,\n                    offset;\n\n                e.preventDefault();\n                e.stopImmediatePropagation();\n\n                setTimeout(function () {\n                    var $window;\n                    var triggerAction = ((root.trigger === 'left' && button === 0) || (root.trigger === 'right' && button === 2));\n\n                    // find the element that would've been clicked, wasn't the layer in the way\n                    if (document.elementFromPoint && root.$layer) {\n                        root.$layer.hide();\n                        target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());\n                        root.$layer.show();\n                    }\n\n                    if (root.reposition && triggerAction) {\n                        if (document.elementFromPoint) {\n                            if (root.$trigger.is(target) || root.$trigger.has(target).length) {\n                                root.position.call(root.$trigger, root, x, y);\n                                return;\n                            }\n                        } else {\n                            offset = root.$trigger.offset();\n                            $window = $(window);\n                            // while this looks kinda awful, it's the best way to avoid\n                            // unnecessarily calculating any positions\n                            offset.top += $window.scrollTop();\n                            if (offset.top <= e.pageY) {\n                                offset.left += $window.scrollLeft();\n                                if (offset.left <= e.pageX) {\n                                    offset.bottom = offset.top + root.$trigger.outerHeight();\n                                    if (offset.bottom >= e.pageY) {\n                                        offset.right = offset.left + root.$trigger.outerWidth();\n                                        if (offset.right >= e.pageX) {\n                                            // reposition\n                                            root.position.call(root.$trigger, root, x, y);\n                                            return;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (target && triggerAction) {\n                        root.$trigger.one('contextmenu:hidden', function () {\n                            $(target).contextMenu({ x: x, y: y, button: button });\n                        });\n                    }\n\n                    if (root != null && root.$menu != null) {\n                        root.$menu.trigger('contextmenu:hide');\n                    }\n                }, 50);\n            },\n            // key handled :hover\n            keyStop: function (e, opt) {\n                if (!opt.isInput) {\n                    e.preventDefault();\n                }\n\n                e.stopPropagation();\n            },\n            key: function (e) {\n\n                var opt = {};\n\n                // Only get the data from $currentTrigger if it exists\n                if ($currentTrigger) {\n                    opt = $currentTrigger.data('contextMenu') || {};\n                }\n                // If the trigger happen on a element that are above the contextmenu do this\n                if (opt.zIndex === undefined) {\n                    opt.zIndex = 0;\n\t\t\t\t}\n                var targetZIndex = 0;\n                var getZIndexOfTriggerTarget = function (target) {\n\t\t\t\t\tif (target.style.zIndex !== '') {\n\t\t\t\t\t\ttargetZIndex = target.style.zIndex;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (target.offsetParent !== null && target.offsetParent !== undefined) {\n\t\t\t\t\t\t\tgetZIndexOfTriggerTarget(target.offsetParent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (target.parentElement !== null && target.parentElement !== undefined) {\n\t\t\t\t\t\t\tgetZIndexOfTriggerTarget(target.parentElement);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                };\n                getZIndexOfTriggerTarget(e.target);\n                // If targetZIndex is heigher then opt.zIndex dont progress any futher.\n                // This is used to make sure that if you are using a dialog with a input / textarea / contenteditable div\n                // and its above the contextmenu it wont steal keys events\n                if (targetZIndex > opt.zIndex) {\n                    return;\n\t\t\t\t}\n                switch (e.keyCode) {\n                    case 9:\n                    case 38: // up\n                        handle.keyStop(e, opt);\n                        // if keyCode is [38 (up)] or [9 (tab) with shift]\n                        if (opt.isInput) {\n                            if (e.keyCode === 9 && e.shiftKey) {\n                                e.preventDefault();\n                                if(opt.$selected) {\n                                    opt.$selected.find('input, textarea, select').blur();\n                                }\n                                if (opt.$menu != null) opt.$menu.trigger('prevcommand');\n                                return;\n                            } else if (e.keyCode === 38 && opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') {\n                                // checkboxes don't capture this key\n                                e.preventDefault();\n                                return;\n                            }\n                        } else if (e.keyCode !== 9 || e.shiftKey) {\n                            if (opt.$menu != null) opt.$menu.trigger('prevcommand');\n                            return;\n                        }\n                        break;\n                    // omitting break;\n                    // case 9: // tab - reached through omitted break;\n                    case 40: // down\n                        handle.keyStop(e, opt);\n                        if (opt.isInput) {\n                            if (e.keyCode === 9) {\n                                e.preventDefault();\n                                if(opt.$selected) {\n                                    opt.$selected.find('input, textarea, select').blur();\n                                }\n                                if (opt.$menu != null) opt.$menu.trigger('nextcommand');\n                                return;\n                            } else if (e.keyCode === 40 && opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') {\n                                // checkboxes don't capture this key\n                                e.preventDefault();\n                                return;\n                            }\n                        } else {\n                            if (opt.$menu != null) opt.$menu.trigger('nextcommand');\n                            return;\n                        }\n                        break;\n\n                    case 37: // left\n                        handle.keyStop(e, opt);\n                        if (opt.isInput || !opt.$selected || !opt.$selected.length) {\n                            break;\n                        }\n\n                        if (!opt.$selected.parent().hasClass('context-menu-root')) {\n                            var $parent = opt.$selected.parent().parent();\n                            opt.$selected.trigger('contextmenu:blur');\n                            opt.$selected = $parent;\n                            return;\n                        }\n                        break;\n\n                    case 39: // right\n                        handle.keyStop(e, opt);\n                        if (opt.isInput || !opt.$selected || !opt.$selected.length) {\n                            break;\n                        }\n\n                        var itemdata = opt.$selected.data('contextMenu') || {};\n                        if (itemdata.$menu && opt.$selected.hasClass('context-menu-submenu')) {\n                            opt.$selected = null;\n                            itemdata.$selected = null;\n                            itemdata.$menu.trigger('nextcommand');\n                            return;\n                        }\n                        break;\n\n                    case 35: // end\n                    case 36: // home\n                        if (opt.$selected && opt.$selected.find('input, textarea, select').length) {\n                            return;\n                        } else {\n                            (opt.$selected && opt.$selected.parent() || opt.$menu)\n                                .children(':not(.' + opt.classNames.disabled + ', .' + opt.classNames.notSelectable + ')')[e.keyCode === 36 ? 'first' : 'last']()\n                                .trigger('contextmenu:focus');\n                            e.preventDefault();\n                            return;\n                        }\n                        break;\n\n                    case 13: // enter\n                        handle.keyStop(e, opt);\n                        if (opt.isInput) {\n                            if (opt.$selected && !opt.$selected.is('textarea, select')) {\n                                e.preventDefault();\n                                return;\n                            }\n                            break;\n                        }\n                        if (typeof opt.$selected !== 'undefined' && opt.$selected !== null) {\n                            opt.$selected.trigger('mouseup');\n                        }\n                        return;\n\n                    case 32: // space\n                    case 33: // page up\n                    case 34: // page down\n                        // prevent browser from scrolling down while menu is visible\n                        handle.keyStop(e, opt);\n                        return;\n\n                    case 27: // esc\n                        handle.keyStop(e, opt);\n                        if (opt.$menu != null) opt.$menu.trigger('contextmenu:hide');\n                        return;\n\n                    default: // 0-9, a-z\n                        var k = (String.fromCharCode(e.keyCode)).toUpperCase();\n                        if (opt.accesskeys && opt.accesskeys[k]) {\n                            // according to the specs accesskeys must be invoked immediately\n                            opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu ? 'contextmenu:focus' : 'mouseup');\n                            return;\n                        }\n                        break;\n                }\n                // pass event to selected item,\n                // stop propagation to avoid endless recursion\n                e.stopPropagation();\n                if (typeof opt.$selected !== 'undefined' && opt.$selected !== null) {\n                    opt.$selected.trigger(e);\n                }\n            },\n            // select previous possible command in menu\n            prevItem: function (e) {\n                e.stopPropagation();\n                var opt = $(this).data('contextMenu') || {};\n                var root = $(this).data('contextMenuRoot') || {};\n\n                // obtain currently selected menu\n                if (opt.$selected) {\n                    var $s = opt.$selected;\n                    opt = opt.$selected.parent().data('contextMenu') || {};\n                    opt.$selected = $s;\n                }\n\n                var $children = opt.$menu.children(),\n                    $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(),\n                    $round = $prev;\n\n                // skip disabled or hidden elements\n                while ($prev.hasClass(root.classNames.disabled) || $prev.hasClass(root.classNames.notSelectable) || $prev.is(':hidden')) {\n                    if ($prev.prev().length) {\n                        $prev = $prev.prev();\n                    } else {\n                        $prev = $children.last();\n                    }\n                    if ($prev.is($round)) {\n                        // break endless loop\n                        return;\n                    }\n                }\n\n                // leave current\n                if (opt.$selected) {\n                    handle.itemMouseleave.call(opt.$selected.get(0), e);\n                }\n\n                // activate next\n                handle.itemMouseenter.call($prev.get(0), e);\n\n                // focus input\n                var $input = $prev.find('input, textarea, select');\n                if ($input.length) {\n                    $input.focus();\n                }\n            },\n            // select next possible command in menu\n            nextItem: function (e) {\n                e.stopPropagation();\n                var opt = $(this).data('contextMenu') || {};\n                var root = $(this).data('contextMenuRoot') || {};\n\n                // obtain currently selected menu\n                if (opt.$selected) {\n                    var $s = opt.$selected;\n                    opt = opt.$selected.parent().data('contextMenu') || {};\n                    opt.$selected = $s;\n                }\n\n                var $children = opt.$menu.children(),\n                    $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(),\n                    $round = $next;\n\n                // skip disabled\n                while ($next.hasClass(root.classNames.disabled) || $next.hasClass(root.classNames.notSelectable) || $next.is(':hidden')) {\n                    if ($next.next().length) {\n                        $next = $next.next();\n                    } else {\n                        $next = $children.first();\n                    }\n                    if ($next.is($round)) {\n                        // break endless loop\n                        return;\n                    }\n                }\n\n                // leave current\n                if (opt.$selected) {\n                    handle.itemMouseleave.call(opt.$selected.get(0), e);\n                }\n\n                // activate next\n                handle.itemMouseenter.call($next.get(0), e);\n\n                // focus input\n                var $input = $next.find('input, textarea, select');\n                if ($input.length) {\n                    $input.focus();\n                }\n            },\n            // flag that we're inside an input so the key handler can act accordingly\n            focusInput: function () {\n                var $this = $(this).closest('.context-menu-item'),\n                    data = $this.data(),\n                    opt = data.contextMenu,\n                    root = data.contextMenuRoot;\n\n                root.$selected = opt.$selected = $this;\n                root.isInput = opt.isInput = true;\n            },\n            // flag that we're inside an input so the key handler can act accordingly\n            blurInput: function () {\n                var $this = $(this).closest('.context-menu-item'),\n                    data = $this.data(),\n                    opt = data.contextMenu,\n                    root = data.contextMenuRoot;\n\n                root.isInput = opt.isInput = false;\n            },\n            // :hover on menu\n            menuMouseenter: function () {\n                var root = $(this).data().contextMenuRoot;\n                root.hovering = true;\n            },\n            // :hover on menu\n            menuMouseleave: function (e) {\n                var root = $(this).data().contextMenuRoot;\n                if (root.$layer && root.$layer.is(e.relatedTarget)) {\n                    root.hovering = false;\n                }\n            },\n            // :hover done manually so key handling is possible\n            itemMouseenter: function (e) {\n                var $this = $(this),\n                    data = $this.data(),\n                    opt = data.contextMenu,\n                    root = data.contextMenuRoot;\n\n                root.hovering = true;\n\n                // abort if we're re-entering\n                if (e && root.$layer && root.$layer.is(e.relatedTarget)) {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                }\n\n                // make sure only one item is selected\n                (opt.$menu ? opt : root).$menu\n                    .children('.' + root.classNames.hover).trigger('contextmenu:blur')\n                    .children('.hover').trigger('contextmenu:blur');\n\n                if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) {\n                    opt.$selected = null;\n                    return;\n                }\n\n                $this.trigger('contextmenu:focus');\n            },\n            // :hover done manually so key handling is possible\n            itemMouseleave: function (e) {\n                var $this = $(this),\n                    data = $this.data(),\n                    opt = data.contextMenu,\n                    root = data.contextMenuRoot;\n\n                if (root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {\n                    if (typeof root.$selected !== 'undefined' && root.$selected !== null) {\n                        root.$selected.trigger('contextmenu:blur');\n                    }\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    root.$selected = opt.$selected = opt.$node;\n                    return;\n                }\n\n                $this.trigger('contextmenu:blur');\n            },\n            // contextMenu item click\n            itemClick: function (e) {\n                var $this = $(this),\n                    data = $this.data(),\n                    opt = data.contextMenu,\n                    root = data.contextMenuRoot,\n                    key = data.contextMenuKey,\n                    callback;\n\n                // abort if the key is unknown or disabled or is a menu\n                if (root.selectableSubMenu && (!opt.items[key] || $this.is('.' + root.classNames.disabled + ', .context-menu-submenu, .context-menu-separator, .' + root.classNames.notSelectable))) {\n                    return;\n                }\n\n                e.preventDefault();\n                e.stopImmediatePropagation();\n\n                if ($.isFunction(opt.callbacks[key]) && Object.prototype.hasOwnProperty.call(opt.callbacks, key)) {\n                    // item-specific callback\n                    callback = opt.callbacks[key];\n                } else if ($.isFunction(root.callback)) {\n                    // default callback\n                    callback = root.callback;\n                } else {\n                    // no callback, no action\n                    return;\n                }\n\n                // hide menu if callback doesn't stop that\n                if (callback.call(root.$trigger, key, root) !== false) {\n                    root.$menu.trigger('contextmenu:hide');\n                } else if (root.$menu.parent().length) {\n                    op.update.call(root.$trigger, root);\n                }\n            },\n            // ignore click events on input elements\n            inputClick: function (e) {\n                e.stopImmediatePropagation();\n            },\n            // hide <menu>\n            hideMenu: function (e, data) {\n                var root = $(this).data('contextMenuRoot');\n                op.hide.call(root.$trigger, root, data && data.force);\n            },\n            // focus <command>\n            focusItem: function (e) {\n                e.stopPropagation();\n                var $this = $(this),\n                    data = $this.data(),\n                    opt = data.contextMenu,\n                    root = data.contextMenuRoot;\n\n                if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) {\n                    return;\n                }\n\n                $this\n                    .addClass([root.classNames.hover, root.classNames.visible].join(' '))\n                    // select other items and included items\n                    .parent().find('.context-menu-item').not($this)\n                    .removeClass(root.classNames.visible)\n                    .filter('.' + root.classNames.hover)\n                    .trigger('contextmenu:blur');\n\n                // remember selected\n                opt.$selected = root.$selected = $this;\n\n                // position sub-menu - do after show so dumb $.ui.position can keep up\n                if (opt.$node) {\n                    root.positionSubmenu.call(opt.$node, opt.$menu);\n                }\n            },\n            // blur <command>\n            blurItem: function (e) {\n                e.stopPropagation();\n                var $this = $(this),\n                    data = $this.data(),\n                    opt = data.contextMenu,\n                    root = data.contextMenuRoot;\n\n                if (opt.autoHide) { // for tablets and touch screens this needs to remain\n                    $this.removeClass(root.classNames.visible);\n                }\n                $this.removeClass(root.classNames.hover);\n                opt.$selected = null;\n            }\n        },\n    // operations\n        op = {\n            show: function (opt, x, y) {\n                var $trigger = $(this),\n                    css = {};\n\n                // hide any open menus\n                $('#context-menu-layer').trigger('mousedown');\n\n                // backreference for callbacks\n                opt.$trigger = $trigger;\n\n                // show event\n                if (opt.events.show.call($trigger, opt) === false) {\n                    $currentTrigger = null;\n                    return;\n                }\n\n                // create or update context menu\n                op.update.call($trigger, opt);\n\n                // position menu\n                opt.position.call($trigger, opt, x, y);\n\n                // make sure we're in front\n                if (opt.zIndex) {\n                  var additionalZValue = opt.zIndex;\n                  // If opt.zIndex is a function, call the function to get the right zIndex.\n                  if (typeof opt.zIndex === 'function') {\n                      additionalZValue = opt.zIndex.call($trigger, opt);\n                  }\n                  css.zIndex = zindex($trigger) + additionalZValue;\n                }\n\n                // add layer\n                op.layer.call(opt.$menu, opt, css.zIndex);\n\n                // adjust sub-menu zIndexes\n                opt.$menu.find('ul').css('zIndex', css.zIndex + 1);\n\n                // position and show context menu\n                opt.$menu.css(css)[opt.animation.show](opt.animation.duration, function () {\n                    $trigger.trigger('contextmenu:visible');\n                });\n                // make options available and set state\n                $trigger\n                    .data('contextMenu', opt)\n                    .addClass('context-menu-active');\n\n                // register key handler\n                $(document).off('keydown.contextMenu').on('keydown.contextMenu', handle.key);\n                // register autoHide handler\n                if (opt.autoHide) {\n                    // mouse position handler\n                    $(document).on('mousemove.contextMenuAutoHide', function (e) {\n                        // need to capture the offset on mousemove,\n                        // since the page might've been scrolled since activation\n                        var pos = $trigger.offset();\n                        pos.right = pos.left + $trigger.outerWidth();\n                        pos.bottom = pos.top + $trigger.outerHeight();\n\n                        if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {\n                            /* Additional hover check after short time, you might just miss the edge of the menu */\n                            setTimeout(function () {\n                                if (!opt.hovering && opt.$menu != null) { opt.$menu.trigger('contextmenu:hide'); }\n                            }, 50);\n                        }\n                    });\n                }\n            },\n            hide: function (opt, force) {\n                var $trigger = $(this);\n                if (!opt) {\n                    opt = $trigger.data('contextMenu') || {};\n                }\n\n                // hide event\n                if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {\n                    return;\n                }\n\n                // remove options and revert state\n                $trigger\n                    .removeData('contextMenu')\n                    .removeClass('context-menu-active');\n\n                if (opt.$layer) {\n                    // keep layer for a bit so the contextmenu event can be aborted properly by opera\n                    setTimeout((function ($layer) {\n                        return function () {\n                            $layer.remove();\n                        };\n                    })(opt.$layer), 10);\n\n                    try {\n                        delete opt.$layer;\n                    } catch (e) {\n                        opt.$layer = null;\n                    }\n                }\n\n                // remove handle\n                $currentTrigger = null;\n                // remove selected\n                opt.$menu.find('.' + opt.classNames.hover).trigger('contextmenu:blur');\n                opt.$selected = null;\n                // collapse all submenus\n                opt.$menu.find('.' + opt.classNames.visible).removeClass(opt.classNames.visible);\n                // unregister key and mouse handlers\n                // $(document).off('.contextMenuAutoHide keydown.contextMenu'); // http://bugs.jquery.com/ticket/10705\n                $(document).off('.contextMenuAutoHide').off('keydown.contextMenu');\n                // hide menu\n                if(opt.$menu){\n                    opt.$menu[opt.animation.hide](opt.animation.duration, function () {\n                        // tear down dynamically built menu after animation is completed.\n                        if (opt.build) {\n                            opt.$menu.remove();\n                            $.each(opt, function (key) {\n                                switch (key) {\n                                    case 'ns':\n                                    case 'selector':\n                                    case 'build':\n                                    case 'trigger':\n                                        return true;\n\n                                    default:\n                                        opt[key] = undefined;\n                                        try {\n                                            delete opt[key];\n                                        } catch (e) {\n                                        }\n                                        return true;\n                                }\n                            });\n                        }\n\n                        setTimeout(function () {\n                            $trigger.trigger('contextmenu:hidden');\n                        }, 10);\n                    });\n                }\n            },\n            create: function (opt, root) {\n                if (root === undefined) {\n                    root = opt;\n                }\n                // create contextMenu\n                opt.$menu = $('<ul class=\"context-menu-list\"></ul>').addClass(opt.className || '').data({\n                    'contextMenu': opt,\n                    'contextMenuRoot': root\n                });\n\n                $.each(['callbacks', 'commands', 'inputs'], function (i, k) {\n                    opt[k] = {};\n                    if (!root[k]) {\n                        root[k] = {};\n                    }\n                });\n\n                if(!root.accesskeys){\n                    root.accesskeys = {};\n                }\n\n                function createNameNode(item) {\n                    var $name = $('<span></span>');\n                    if (item._accesskey) {\n                        if (item._beforeAccesskey) {\n                            $name.append(document.createTextNode(item._beforeAccesskey));\n                        }\n                        $('<span></span>')\n                            .addClass('context-menu-accesskey')\n                            .text(item._accesskey)\n                            .appendTo($name);\n                        if (item._afterAccesskey) {\n                            $name.append(document.createTextNode(item._afterAccesskey));\n                        }\n                    } else {\n                        if (item.isHtmlName) {\n                            // restrict use with access keys\n                            if (typeof item.accesskey !== 'undefined') {\n                                throw new Error('accesskeys are not compatible with HTML names and cannot be used together in the same item');\n                            }\n                            $name.html(item.name);\n                        } else {\n                            $name.text(item.name);\n                        }\n                    }\n                    return $name;\n                }\n\n                // create contextMenu items\n                $.each(opt.items, function (key, item) {\n                    var $t = $('<li class=\"context-menu-item\"></li>').addClass(item.className || ''),\n                        $label = null,\n                        $input = null;\n\n                    // iOS needs to see a click-event bound to an element to actually\n                    // have the TouchEvents infrastructure trigger the click event\n                    $t.on('click', $.noop);\n\n                    // Make old school string seperator a real item so checks wont be\n                    // akward later.\n                    // And normalize 'cm_separator' into 'cm_seperator'.\n                    if (typeof item === 'string' || item.type === 'cm_separator') {\n                        item = { type : 'cm_seperator' };\n                    }\n\n                    item.$node = $t.data({\n                        'contextMenu': opt,\n                        'contextMenuRoot': root,\n                        'contextMenuKey': key\n                    });\n\n                    // register accesskey\n                    // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that\n                    if (typeof item.accesskey !== 'undefined') {\n                        var aks = splitAccesskey(item.accesskey);\n                        for (var i = 0, ak; ak = aks[i]; i++) {\n                            if (!root.accesskeys[ak]) {\n                                root.accesskeys[ak] = item;\n                                var matched = item.name.match(new RegExp('^(.*?)(' + ak + ')(.*)$', 'i'));\n                                if (matched) {\n                                    item._beforeAccesskey = matched[1];\n                                    item._accesskey = matched[2];\n                                    item._afterAccesskey = matched[3];\n                                }\n                                break;\n                            }\n                        }\n                    }\n\n                    if (item.type && types[item.type]) {\n                        // run custom type handler\n                        types[item.type].call($t, item, opt, root);\n                        // register commands\n                        $.each([opt, root], function (i, k) {\n                            k.commands[key] = item;\n                            // Overwrite only if undefined or the item is appended to the root. This so it\n                            // doesn't overwrite callbacks of root elements if the name is the same.\n                            if ($.isFunction(item.callback) && (k.callbacks[key] === undefined || opt.type === undefined)) {\n                                k.callbacks[key] = item.callback;\n                            }\n                        });\n                    } else {\n                        // add label for input\n                        if (item.type === 'cm_seperator') {\n                            $t.addClass('context-menu-separator ' + root.classNames.notSelectable);\n                        } else if (item.type === 'html') {\n                            $t.addClass('context-menu-html ' + root.classNames.notSelectable);\n                        } else if (item.type === 'sub') {\n                           // We don't want to execute the next else-if if it is a sub.\n                        } else if (item.type) {\n                            $label = $('<label></label>').appendTo($t);\n                            createNameNode(item).appendTo($label);\n\n                            $t.addClass('context-menu-input');\n                            opt.hasTypes = true;\n                            $.each([opt, root], function (i, k) {\n                                k.commands[key] = item;\n                                k.inputs[key] = item;\n                            });\n                        } else if (item.items) {\n                            item.type = 'sub';\n                        }\n\n                        switch (item.type) {\n                            case 'cm_seperator':\n                                break;\n\n                            case 'text':\n                                $input = $('<input type=\"text\" value=\"1\" name=\"\" />')\n                                    .attr('name', 'context-menu-input-' + key)\n                                    .val(item.value || '')\n                                    .appendTo($label);\n                                break;\n\n                            case 'textarea':\n                                $input = $('<textarea name=\"\"></textarea>')\n                                    .attr('name', 'context-menu-input-' + key)\n                                    .val(item.value || '')\n                                    .appendTo($label);\n\n                                if (item.height) {\n                                    $input.height(item.height);\n                                }\n                                break;\n\n                            case 'checkbox':\n                                $input = $('<input type=\"checkbox\" value=\"1\" name=\"\" />')\n                                    .attr('name', 'context-menu-input-' + key)\n                                    .val(item.value || '')\n                                    .prop('checked', !!item.selected)\n                                    .prependTo($label);\n                                break;\n\n                            case 'radio':\n                                $input = $('<input type=\"radio\" value=\"1\" name=\"\" />')\n                                    .attr('name', 'context-menu-input-' + item.radio)\n                                    .val(item.value || '')\n                                    .prop('checked', !!item.selected)\n                                    .prependTo($label);\n                                break;\n\n                            case 'select':\n                                $input = $('<select name=\"\"></select>')\n                                    .attr('name', 'context-menu-input-' + key)\n                                    .appendTo($label);\n                                if (item.options) {\n                                    $.each(item.options, function (value, text) {\n                                        $('<option></option>').val(value).text(text).appendTo($input);\n                                    });\n                                    $input.val(item.selected);\n                                }\n                                break;\n\n                            case 'sub':\n                                createNameNode(item).appendTo($t);\n                                item.appendTo = item.$node;\n                                $t.data('contextMenu', item).addClass('context-menu-submenu');\n                                item.callback = null;\n\n                                // If item contains items, and this is a promise, we should create it later\n                                // check if subitems is of type promise. If it is a promise we need to create\n                                // it later, after promise has been resolved.\n                                if ('function' === typeof item.items.then) {\n                                  // probably a promise, process it, when completed it will create the sub menu's.\n                                  op.processPromises(item, root, item.items);\n                                } else {\n                                  // normal submenu.\n                                  op.create(item, root);\n                                }\n                                break;\n\n                            case 'html':\n                                $(item.html).appendTo($t);\n                                break;\n\n                            default:\n                                $.each([opt, root], function (i, k) {\n                                    k.commands[key] = item;\n                                    // Overwrite only if undefined or the item is appended to the root. This so it\n                                    // doesn't overwrite callbacks of root elements if the name is the same.\n                                    if ($.isFunction(item.callback) && (k.callbacks[key] === undefined || opt.type === undefined)) {\n                                        k.callbacks[key] = item.callback;\n                                    }\n                                });\n                                createNameNode(item).appendTo($t);\n                                break;\n                        }\n\n                        // disable key listener in <input>\n                        if (item.type && item.type !== 'sub' && item.type !== 'html' && item.type !== 'cm_seperator') {\n                            $input\n                                .on('focus', handle.focusInput)\n                                .on('blur', handle.blurInput);\n\n                            if (item.events) {\n                                $input.on(item.events, opt);\n                            }\n                        }\n\n                        // add icons\n                        if (item.icon) {\n                            if ($.isFunction(item.icon)) {\n                                item._icon = item.icon.call(this, this, $t, key, item);\n                            } else {\n                                if ( typeof(item.icon) === 'string' && item.icon.substring(0,3) == 'fa-' ) {\n                                    // to enable font awesome\n                                    item._icon = root.classNames.icon + ' ' + root.classNames.icon + '--fa fa ' + item.icon;\n                                } else {\n                                    item._icon = root.classNames.icon + ' ' + root.classNames.icon + '-' + item.icon;\n                                }\n                            }\n                            $t.addClass(item._icon);\n                        }\n                    }\n\n                    // cache contained elements\n                    item.$input = $input;\n                    item.$label = $label;\n\n                    // attach item to menu\n                    $t.appendTo(opt.$menu);\n\n                    // Disable text selection\n                    if (!opt.hasTypes && $.support.eventSelectstart) {\n                        // browsers support user-select: none,\n                        // IE has a special event for text-selection\n                        // browsers supporting neither will not be preventing text-selection\n                        $t.on('selectstart.disableTextSelect', handle.abortevent);\n                    }\n                });\n                // attach contextMenu to <body> (to bypass any possible overflow:hidden issues on parents of the trigger element)\n                if (!opt.$node) {\n                    opt.$menu.css('display', 'none').addClass('context-menu-root');\n                }\n                opt.$menu.appendTo(opt.appendTo || document.body);\n            },\n            resize: function ($menu, nested) {\n                var domMenu;\n                // determine widths of submenus, as CSS won't grow them automatically\n                // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100;\n                // kinda sucks hard...\n\n                // determine width of absolutely positioned element\n                $menu.css({position: 'absolute', display: 'block'});\n                // don't apply yet, because that would break nested elements' widths\n                $menu.data('width',\n                    (domMenu = $menu.get(0)).getBoundingClientRect ?\n                        Math.ceil(domMenu.getBoundingClientRect().width) :\n                        $menu.outerWidth() + 1); // outerWidth() returns rounded pixels\n                // reset styles so they allow nested elements to grow/shrink naturally\n                $menu.css({\n                    position: 'static',\n                    minWidth: '0px',\n                    maxWidth: '100000px'\n                });\n                // identify width of nested menus\n                $menu.find('> li > ul').each(function () {\n                    op.resize($(this), true);\n                });\n                // reset and apply changes in the end because nested\n                // elements' widths wouldn't be calculatable otherwise\n                if (!nested) {\n                    $menu.find('ul').addBack().css({\n                        position: '',\n                        display: '',\n                        minWidth: '',\n                        maxWidth: ''\n                    }).outerWidth(function () {\n                        return $(this).data('width');\n                    });\n                }\n            },\n            update: function (opt, root) {\n                var $trigger = this;\n                if (root === undefined) {\n                    root = opt;\n                    op.resize(opt.$menu);\n                }\n                // re-check disabled for each item\n                opt.$menu.children().each(function () {\n                    var $item = $(this),\n                        key = $item.data('contextMenuKey'),\n                        item = opt.items[key],\n                        disabled = ($.isFunction(item.disabled) && item.disabled.call($trigger, key, root)) || item.disabled === true,\n                        visible;\n                    if ($.isFunction(item.visible)) {\n                        visible = item.visible.call($trigger, key, root);\n                    } else if (typeof item.visible !== 'undefined') {\n                        visible = item.visible === true;\n                    } else {\n                        visible = true;\n                    }\n                    $item[visible ? 'show' : 'hide']();\n\n                    // dis- / enable item\n                    $item[disabled ? 'addClass' : 'removeClass'](root.classNames.disabled);\n\n                    if ($.isFunction(item.icon)) {\n                        $item.removeClass(item._icon);\n                        item._icon = item.icon.call(this, $trigger, $item, key, item);\n                        $item.addClass(item._icon);\n                    }\n\n                    if (item.type) {\n                        // dis- / enable input elements\n                        $item.find('input, select, textarea').prop('disabled', disabled);\n\n                        // update input states\n                        switch (item.type) {\n                            case 'text':\n                            case 'textarea':\n                                item.$input.val(item.value || '');\n                                break;\n\n                            case 'checkbox':\n                            case 'radio':\n                                item.$input.val(item.value || '').prop('checked', !!item.selected);\n                                break;\n\n                            case 'select':\n                                item.$input.val(item.selected || '');\n                                break;\n                        }\n                    }\n\n                    if (item.$menu) {\n                        // update sub-menu\n                        op.update.call($trigger, item, root);\n                    }\n                });\n            },\n            layer: function (opt, zIndex) {\n                // add transparent layer for click area\n                // filter and background for Internet Explorer, Issue #23\n                var $layer = opt.$layer = $('<div id=\"context-menu-layer\" style=\"position:fixed; z-index:' + zIndex + '; top:0; left:0; opacity: 0; filter: alpha(opacity=0); background-color: #000;\"></div>')\n                    .css({height: $win.height(), width: $win.width(), display: 'block'})\n                    .data('contextMenuRoot', opt)\n                    .insertBefore(this)\n                    .on('contextmenu', handle.abortevent)\n                    .on('mousedown', handle.layerClick);\n\n                // IE6 doesn't know position:fixed;\n                if (document.body.style.maxWidth === undefined) { // IE6 doesn't support maxWidth\n                    $layer.css({\n                        'position': 'absolute',\n                        'height': $(document).height()\n                    });\n                }\n\n                return $layer;\n            },\n            processPromises: function (opt, root, promise) {\n                // Start\n                opt.$node.addClass(root.classNames.iconLoadingClass);\n\n                function completedPromise(opt,root,items) {\n                    // Completed promise (dev called promise.resolve). We now have a list of items which can\n                    // be used to create the rest of the context menu.\n                    if (items === undefined) {\n                        // Null result, dev should have checked\n                        errorPromise(undefined);//own error object\n                    }\n                    finishPromiseProcess(opt,root, items);\n                };\n                function errorPromise(opt,root,errorItem) {\n                    // User called promise.reject() with an error item, if not, provide own error item.\n                    if (errorItem === undefined) {\n                        errorItem = { \"error\": { name: \"No items and no error item\", icon: \"context-menu-icon context-menu-icon-quit\" } };\n                        if (window.console) {\n                            (console.error || console.log).call(console, 'When you reject a promise, provide an \"items\" object, equal to normal sub-menu items');\n                        }\n                    } else if(typeof errorItem === 'string'){\n\t\t\t\t\t\t            errorItem = { \"error\": { name: errorItem } };\n\t\t\t\t\t          }\n                    finishPromiseProcess(opt,root,errorItem);\n                };\n                function finishPromiseProcess(opt,root,items) {\n                    if(root.$menu === undefined || !root.$menu.is(':visible')){\n                        return;\n                    }\n                    opt.$node.removeClass(root.classNames.iconLoadingClass);\n                    opt.items = items;\n                    op.create(opt, root, true); // Create submenu\n                    op.update(opt, root); // Correctly update position if user is already hovered over menu item\n                    root.positionSubmenu.call(opt.$node, opt.$menu); // positionSubmenu, will only do anything if user already hovered over menu item that just got new subitems.\n                };\n\n                // Wait for promise completion. .then(success, error, notify) (we don't track notify). Bind the opt\n                // and root to avoid scope problems\n                promise.then(completedPromise.bind(this, opt, root), errorPromise.bind(this, opt, root));\n            }\n        };\n\n    // split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key\n    function splitAccesskey(val) {\n        var t = val.split(/\\s+/),\n            keys = [];\n\n        for (var i = 0, k; k = t[i]; i++) {\n            k = k.charAt(0).toUpperCase(); // first character only\n            // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it.\n            // a map to look up already used access keys would be nice\n            keys.push(k);\n        }\n\n        return keys;\n    }\n\n// handle contextMenu triggers\n    $.fn.contextMenu = function (operation) {\n        var $t = this, $o = operation;\n        if (this.length > 0) {  // this is not a build on demand menu\n            if (operation === undefined) {\n                this.first().trigger('contextmenu');\n            } else if (operation.x !== undefined && operation.y !== undefined) {\n                this.first().trigger($.Event('contextmenu', { pageX: operation.x, pageY: operation.y, mouseButton: operation.button }));\n            } else if (operation === 'hide') {\n                var $menu = this.first().data('contextMenu') ? this.first().data('contextMenu').$menu : null;\n                if($menu){\n                    $menu.trigger('contextmenu:hide');\n                }\n            } else if (operation === 'destroy') {\n                $.contextMenu('destroy', {context: this});\n            } else if ($.isPlainObject(operation)) {\n                operation.context = this;\n                $.contextMenu('create', operation);\n            } else if (operation) {\n                this.removeClass('context-menu-disabled');\n            } else if (!operation) {\n                this.addClass('context-menu-disabled');\n            }\n        } else {\n            $.each(menus, function () {\n                if (this.selector === $t.selector) {\n                    $o.data = this;\n\n                    $.extend($o.data, {trigger: 'demand'});\n                }\n            });\n\n            handle.contextmenu.call($o.target, $o);\n        }\n\n        return this;\n    };\n\n    // manage contextMenu instances\n    $.contextMenu = function (operation, options) {\n\n        if (typeof operation !== 'string') {\n            options = operation;\n            operation = 'create';\n        }\n\n        if (typeof options === 'string') {\n            options = {selector: options};\n        } else if (options === undefined) {\n            options = {};\n        }\n\n        // merge with default options\n        var o = $.extend(true, {}, defaults, options || {});\n        var $document = $(document);\n        var $context = $document;\n        var _hasContext = false;\n\n        if (!o.context || !o.context.length) {\n            o.context = document;\n        } else {\n            // you never know what they throw at you...\n            $context = $(o.context).first();\n            o.context = $context.get(0);\n            _hasContext = !$(o.context).is(document);\n        }\n\n        switch (operation) {\n            case 'create':\n                // no selector no joy\n                if (!o.selector) {\n                    throw new Error('No selector specified');\n                }\n                // make sure internal classes are not bound to\n                if (o.selector.match(/.context-menu-(list|item|input)($|\\s)/)) {\n                    throw new Error('Cannot bind to selector \"' + o.selector + '\" as it contains a reserved className');\n                }\n                if (!o.build && (!o.items || $.isEmptyObject(o.items))) {\n                    throw new Error('No Items specified');\n                }\n                counter++;\n                o.ns = '.contextMenu' + counter;\n                if (!_hasContext) {\n                    namespaces[o.selector] = o.ns;\n                }\n                menus[o.ns] = o;\n\n                // default to right click\n                if (!o.trigger) {\n                    o.trigger = 'right';\n                }\n\n                if (!initialized) {\n                    var itemClick = o.itemClickEvent === 'click' ? 'click.contextMenu' : 'mouseup.contextMenu';\n                    var contextMenuItemObj = {\n                            // 'mouseup.contextMenu': handle.itemClick,\n                            // 'click.contextMenu': handle.itemClick,\n                            'contextmenu:focus.contextMenu': handle.focusItem,\n                            'contextmenu:blur.contextMenu': handle.blurItem,\n                            'contextmenu.contextMenu': handle.abortevent,\n                            'mouseenter.contextMenu': handle.itemMouseenter,\n                            'mouseleave.contextMenu': handle.itemMouseleave\n                        };\n                    contextMenuItemObj[itemClick] = handle.itemClick;\n                    // make sure item click is registered first\n                    $document\n                        .on({\n                            'contextmenu:hide.contextMenu': handle.hideMenu,\n                            'prevcommand.contextMenu': handle.prevItem,\n                            'nextcommand.contextMenu': handle.nextItem,\n                            'contextmenu.contextMenu': handle.abortevent,\n                            'mouseenter.contextMenu': handle.menuMouseenter,\n                            'mouseleave.contextMenu': handle.menuMouseleave\n                        }, '.context-menu-list')\n                        .on('mouseup.contextMenu', '.context-menu-input', handle.inputClick)\n                        .on(contextMenuItemObj, '.context-menu-item');\n\n                    initialized = true;\n                }\n\n                // engage native contextmenu event\n                $context\n                    .on('contextmenu' + o.ns, o.selector, o, handle.contextmenu);\n\n                if (_hasContext) {\n                    // add remove hook, just in case\n                    $context.on('remove' + o.ns, function () {\n                        $(this).contextMenu('destroy');\n                    });\n                }\n\n                switch (o.trigger) {\n                    case 'hover':\n                        $context\n                            .on('mouseenter' + o.ns, o.selector, o, handle.mouseenter)\n                            .on('mouseleave' + o.ns, o.selector, o, handle.mouseleave);\n                        break;\n\n                    case 'left':\n                        $context.on('click' + o.ns, o.selector, o, handle.click);\n                        break;\n                    /*\n                     default:\n                     // http://www.quirksmode.org/dom/events/contextmenu.html\n                     $document\n                     .on('mousedown' + o.ns, o.selector, o, handle.mousedown)\n                     .on('mouseup' + o.ns, o.selector, o, handle.mouseup);\n                     break;\n                     */\n                }\n\n                // create menu\n                if (!o.build) {\n                    op.create(o);\n                }\n                break;\n\n            case 'destroy':\n                var $visibleMenu;\n                if (_hasContext) {\n                    // get proper options\n                    var context = o.context;\n                    $.each(menus, function (ns, o) {\n                        \n                        if (!o) {\n                            return true;\n                        }\n\n                        // Is this menu equest to the context called from\n                        if (!$(context).is(o.selector)) {\n                            return true;\n                        }\n\n                        $visibleMenu = $('.context-menu-list').filter(':visible');\n                        if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {\n                            $visibleMenu.trigger('contextmenu:hide', {force: true});\n                        }\n\n                        try {\n                            if (menus[o.ns].$menu) {\n                                menus[o.ns].$menu.remove();\n                            }\n\n                            delete menus[o.ns];\n                        } catch (e) {\n                            menus[o.ns] = null;\n                        }\n\n                        $(o.context).off(o.ns);\n\n                        return true;\n                    });\n                } else if (!o.selector) {\n                    $document.off('.contextMenu .contextMenuAutoHide');\n                    $.each(menus, function (ns, o) {\n                        $(o.context).off(o.ns);\n                    });\n\n                    namespaces = {};\n                    menus = {};\n                    counter = 0;\n                    initialized = false;\n\n                    $('#context-menu-layer, .context-menu-list').remove();\n                } else if (namespaces[o.selector]) {\n                    $visibleMenu = $('.context-menu-list').filter(':visible');\n                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {\n                        $visibleMenu.trigger('contextmenu:hide', {force: true});\n                    }\n\n                    try {\n                        if (menus[namespaces[o.selector]].$menu) {\n                            menus[namespaces[o.selector]].$menu.remove();\n                        }\n\n                        delete menus[namespaces[o.selector]];\n                    } catch (e) {\n                        menus[namespaces[o.selector]] = null;\n                    }\n\n                    $document.off(namespaces[o.selector]);\n                }\n                break;\n\n            case 'html5':\n                // if <command> or <menuitem> are not handled by the browser,\n                // or options was a bool true,\n                // initialize $.contextMenu for them\n                if ((!$.support.htmlCommand && !$.support.htmlMenuitem) || (typeof options === 'boolean' && options)) {\n                    $('menu[type=\"context\"]').each(function () {\n                        if (this.id) {\n                            $.contextMenu({\n                                selector: '[contextmenu=' + this.id + ']',\n                                items: $.contextMenu.fromMenu(this)\n                            });\n                        }\n                    }).css('display', 'none');\n                }\n                break;\n\n            default:\n                throw new Error('Unknown operation \"' + operation + '\"');\n        }\n\n        return this;\n    };\n\n// import values into <input> commands\n    $.contextMenu.setInputValues = function (opt, data) {\n        if (data === undefined) {\n            data = {};\n        }\n\n        $.each(opt.inputs, function (key, item) {\n            switch (item.type) {\n                case 'text':\n                case 'textarea':\n                    item.value = data[key] || '';\n                    break;\n\n                case 'checkbox':\n                    item.selected = data[key] ? true : false;\n                    break;\n\n                case 'radio':\n                    item.selected = (data[item.radio] || '') === item.value;\n                    break;\n\n                case 'select':\n                    item.selected = data[key] || '';\n                    break;\n            }\n        });\n    };\n\n// export values from <input> commands\n    $.contextMenu.getInputValues = function (opt, data) {\n        if (data === undefined) {\n            data = {};\n        }\n\n        $.each(opt.inputs, function (key, item) {\n            switch (item.type) {\n                case 'text':\n                case 'textarea':\n                case 'select':\n                    data[key] = item.$input.val();\n                    break;\n\n                case 'checkbox':\n                    data[key] = item.$input.prop('checked');\n                    break;\n\n                case 'radio':\n                    if (item.$input.prop('checked')) {\n                        data[item.radio] = item.value;\n                    }\n                    break;\n            }\n        });\n\n        return data;\n    };\n\n// find <label for=\"xyz\">\n    function inputLabel(node) {\n        return (node.id && $('label[for=\"' + node.id + '\"]').val()) || node.name;\n    }\n\n// convert <menu> to items object\n    function menuChildren(items, $children, counter) {\n        if (!counter) {\n            counter = 0;\n        }\n\n        $children.each(function () {\n            var $node = $(this),\n                node = this,\n                nodeName = this.nodeName.toLowerCase(),\n                label,\n                item;\n\n            // extract <label><input>\n            if (nodeName === 'label' && $node.find('input, textarea, select').length) {\n                label = $node.text();\n                $node = $node.children().first();\n                node = $node.get(0);\n                nodeName = node.nodeName.toLowerCase();\n            }\n\n            /*\n             * <menu> accepts flow-content as children. that means <embed>, <canvas> and such are valid menu items.\n             * Not being the sadistic kind, $.contextMenu only accepts:\n             * <command>, <menuitem>, <hr>, <span>, <p> <input [text, radio, checkbox]>, <textarea>, <select> and of course <menu>.\n             * Everything else will be imported as an html node, which is not interfaced with contextMenu.\n             */\n\n            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command\n            switch (nodeName) {\n                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element\n                case 'menu':\n                    item = {name: $node.attr('label'), items: {}};\n                    counter = menuChildren(item.items, $node.children(), counter);\n                    break;\n\n                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command\n                case 'a':\n                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command\n                case 'button':\n                    item = {\n                        name: $node.text(),\n                        disabled: !!$node.attr('disabled'),\n                        callback: (function () {\n                            return function () {\n                                $node.click();\n                            };\n                        })()\n                    };\n                    break;\n\n                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command\n\n                case 'menuitem':\n                case 'command':\n                    switch ($node.attr('type')) {\n                        case undefined:\n                        case 'command':\n                        case 'menuitem':\n                            item = {\n                                name: $node.attr('label'),\n                                disabled: !!$node.attr('disabled'),\n                                icon: $node.attr('icon'),\n                                callback: (function () {\n                                    return function () {\n                                        $node.click();\n                                    };\n                                })()\n                            };\n                            break;\n\n                        case 'checkbox':\n                            item = {\n                                type: 'checkbox',\n                                disabled: !!$node.attr('disabled'),\n                                name: $node.attr('label'),\n                                selected: !!$node.attr('checked')\n                            };\n                            break;\n                        case 'radio':\n                            item = {\n                                type: 'radio',\n                                disabled: !!$node.attr('disabled'),\n                                name: $node.attr('label'),\n                                radio: $node.attr('radiogroup'),\n                                value: $node.attr('id'),\n                                selected: !!$node.attr('checked')\n                            };\n                            break;\n\n                        default:\n                            item = undefined;\n                    }\n                    break;\n\n                case 'hr':\n                    item = '-------';\n                    break;\n\n                case 'input':\n                    switch ($node.attr('type')) {\n                        case 'text':\n                            item = {\n                                type: 'text',\n                                name: label || inputLabel(node),\n                                disabled: !!$node.attr('disabled'),\n                                value: $node.val()\n                            };\n                            break;\n\n                        case 'checkbox':\n                            item = {\n                                type: 'checkbox',\n                                name: label || inputLabel(node),\n                                disabled: !!$node.attr('disabled'),\n                                selected: !!$node.attr('checked')\n                            };\n                            break;\n\n                        case 'radio':\n                            item = {\n                                type: 'radio',\n                                name: label || inputLabel(node),\n                                disabled: !!$node.attr('disabled'),\n                                radio: !!$node.attr('name'),\n                                value: $node.val(),\n                                selected: !!$node.attr('checked')\n                            };\n                            break;\n\n                        default:\n                            item = undefined;\n                            break;\n                    }\n                    break;\n\n                case 'select':\n                    item = {\n                        type: 'select',\n                        name: label || inputLabel(node),\n                        disabled: !!$node.attr('disabled'),\n                        selected: $node.val(),\n                        options: {}\n                    };\n                    $node.children().each(function () {\n                        item.options[this.value] = $(this).text();\n                    });\n                    break;\n\n                case 'textarea':\n                    item = {\n                        type: 'textarea',\n                        name: label || inputLabel(node),\n                        disabled: !!$node.attr('disabled'),\n                        value: $node.val()\n                    };\n                    break;\n\n                case 'label':\n                    break;\n\n                default:\n                    item = {type: 'html', html: $node.clone(true)};\n                    break;\n            }\n\n            if (item) {\n                counter++;\n                items['key' + counter] = item;\n            }\n        });\n\n        return counter;\n    }\n\n// convert html5 menu\n    $.contextMenu.fromMenu = function (element) {\n        var $this = $(element),\n            items = {};\n\n        menuChildren(items, $this.children());\n\n        return items;\n    };\n\n// make defaults accessible\n    $.contextMenu.defaults = defaults;\n    $.contextMenu.types = types;\n// export internal functions - undocumented, for hacking only!\n    $.contextMenu.handle = handle;\n    $.contextMenu.op = op;\n    $.contextMenu.menus = menus;\n\n\n});\n","/*! jQuery UI - v1.12.1 - 2016-09-16\n * http://jqueryui.com\n * Includes: position.js\n * Copyright jQuery Foundation and other contributors; Licensed MIT */\n\n(function( factory ) {\n    if ( typeof define === \"function\" && define.amd ) {\n\n        // AMD. Register as an anonymous module.\n        define([ \"jquery\" ], factory );\n    } else {\n\n        // Browser globals\n        factory( jQuery );\n    }\n}(function( $ ) {\n\n    $.ui = $.ui || {};\n\n    var version = $.ui.version = \"1.12.1\";\n\n\n    /*!\n     * jQuery UI Position 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     *\n     * http://api.jqueryui.com/position/\n     */\n\n//>>label: Position\n//>>group: Core\n//>>description: Positions elements relative to other elements.\n//>>docs: http://api.jqueryui.com/position/\n//>>demos: http://jqueryui.com/position/\n\n\n    ( function() {\n        var cachedScrollbarWidth,\n            max = Math.max,\n            abs = Math.abs,\n            rhorizontal = /left|center|right/,\n            rvertical = /top|center|bottom/,\n            roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n            rposition = /^\\w+/,\n            rpercent = /%$/,\n            _position = $.fn.position;\n\n        function getOffsets( offsets, width, height ) {\n            return [\n                parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n                parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n            ];\n        }\n\n        function parseCss( element, property ) {\n            return parseInt( $.css( element, property ), 10 ) || 0;\n        }\n\n        function getDimensions( elem ) {\n            var raw = elem[ 0 ];\n            if ( raw.nodeType === 9 ) {\n                return {\n                    width: elem.width(),\n                    height: elem.height(),\n                    offset: { top: 0, left: 0 }\n                };\n            }\n            if ( $.isWindow( raw ) ) {\n                return {\n                    width: elem.width(),\n                    height: elem.height(),\n                    offset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n                };\n            }\n            if ( raw.preventDefault ) {\n                return {\n                    width: 0,\n                    height: 0,\n                    offset: { top: raw.pageY, left: raw.pageX }\n                };\n            }\n            return {\n                width: elem.outerWidth(),\n                height: elem.outerHeight(),\n                offset: elem.offset()\n            };\n        }\n\n        $.position = {\n            scrollbarWidth: function() {\n                if ( cachedScrollbarWidth !== undefined ) {\n                    return cachedScrollbarWidth;\n                }\n                var w1, w2,\n                    div = $( \"<div \" +\n                        \"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>\" +\n                        \"<div style='height:100px;width:auto;'></div></div>\" ),\n                    innerDiv = div.children()[ 0 ];\n\n                $( \"body\" ).append( div );\n                w1 = innerDiv.offsetWidth;\n                div.css( \"overflow\", \"scroll\" );\n\n                w2 = innerDiv.offsetWidth;\n\n                if ( w1 === w2 ) {\n                    w2 = div[ 0 ].clientWidth;\n                }\n\n                div.remove();\n\n                return ( cachedScrollbarWidth = w1 - w2 );\n            },\n            getScrollInfo: function( within ) {\n                var overflowX = within.isWindow || within.isDocument ? \"\" :\n                        within.element.css( \"overflow-x\" ),\n                    overflowY = within.isWindow || within.isDocument ? \"\" :\n                        within.element.css( \"overflow-y\" ),\n                    hasOverflowX = overflowX === \"scroll\" ||\n                        ( overflowX === \"auto\" && within.width < within.element[ 0 ].scrollWidth ),\n                    hasOverflowY = overflowY === \"scroll\" ||\n                        ( overflowY === \"auto\" && within.height < within.element[ 0 ].scrollHeight );\n                return {\n                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,\n                    height: hasOverflowX ? $.position.scrollbarWidth() : 0\n                };\n            },\n            getWithinInfo: function( element ) {\n                var withinElement = $( element || window ),\n                    isWindow = $.isWindow( withinElement[ 0 ] ),\n                    isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,\n                    hasOffset = !isWindow && !isDocument;\n                return {\n                    element: withinElement,\n                    isWindow: isWindow,\n                    isDocument: isDocument,\n                    offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },\n                    scrollLeft: withinElement.scrollLeft(),\n                    scrollTop: withinElement.scrollTop(),\n                    width: withinElement.outerWidth(),\n                    height: withinElement.outerHeight()\n                };\n            }\n        };\n\n        $.fn.position = function( options ) {\n            if ( !options || !options.of ) {\n                return _position.apply( this, arguments );\n            }\n\n            // Make a copy, we don't want to modify arguments\n            options = $.extend( {}, options );\n\n            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n                target = $( options.of ),\n                within = $.position.getWithinInfo( options.within ),\n                scrollInfo = $.position.getScrollInfo( within ),\n                collision = ( options.collision || \"flip\" ).split( \" \" ),\n                offsets = {};\n\n            dimensions = getDimensions( target );\n            if ( target[ 0 ].preventDefault ) {\n\n                // Force left top to allow flipping\n                options.at = \"left top\";\n            }\n            targetWidth = dimensions.width;\n            targetHeight = dimensions.height;\n            targetOffset = dimensions.offset;\n\n            // Clone to reuse original targetOffset later\n            basePosition = $.extend( {}, targetOffset );\n\n            // Force my and at to have valid horizontal and vertical positions\n            // if a value is missing or invalid, it will be converted to center\n            $.each( [ \"my\", \"at\" ], function() {\n                var pos = ( options[ this ] || \"\" ).split( \" \" ),\n                    horizontalOffset,\n                    verticalOffset;\n\n                if ( pos.length === 1 ) {\n                    pos = rhorizontal.test( pos[ 0 ] ) ?\n                        pos.concat( [ \"center\" ] ) :\n                        rvertical.test( pos[ 0 ] ) ?\n                            [ \"center\" ].concat( pos ) :\n                            [ \"center\", \"center\" ];\n                }\n                pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n                pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n                // Calculate offsets\n                horizontalOffset = roffset.exec( pos[ 0 ] );\n                verticalOffset = roffset.exec( pos[ 1 ] );\n                offsets[ this ] = [\n                    horizontalOffset ? horizontalOffset[ 0 ] : 0,\n                    verticalOffset ? verticalOffset[ 0 ] : 0\n                ];\n\n                // Reduce to just the positions without the offsets\n                options[ this ] = [\n                    rposition.exec( pos[ 0 ] )[ 0 ],\n                    rposition.exec( pos[ 1 ] )[ 0 ]\n                ];\n            } );\n\n            // Normalize collision option\n            if ( collision.length === 1 ) {\n                collision[ 1 ] = collision[ 0 ];\n            }\n\n            if ( options.at[ 0 ] === \"right\" ) {\n                basePosition.left += targetWidth;\n            } else if ( options.at[ 0 ] === \"center\" ) {\n                basePosition.left += targetWidth / 2;\n            }\n\n            if ( options.at[ 1 ] === \"bottom\" ) {\n                basePosition.top += targetHeight;\n            } else if ( options.at[ 1 ] === \"center\" ) {\n                basePosition.top += targetHeight / 2;\n            }\n\n            atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n            basePosition.left += atOffset[ 0 ];\n            basePosition.top += atOffset[ 1 ];\n\n            return this.each( function() {\n                var collisionPosition, using,\n                    elem = $( this ),\n                    elemWidth = elem.outerWidth(),\n                    elemHeight = elem.outerHeight(),\n                    marginLeft = parseCss( this, \"marginLeft\" ),\n                    marginTop = parseCss( this, \"marginTop\" ),\n                    collisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) +\n                        scrollInfo.width,\n                    collisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) +\n                        scrollInfo.height,\n                    position = $.extend( {}, basePosition ),\n                    myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n                if ( options.my[ 0 ] === \"right\" ) {\n                    position.left -= elemWidth;\n                } else if ( options.my[ 0 ] === \"center\" ) {\n                    position.left -= elemWidth / 2;\n                }\n\n                if ( options.my[ 1 ] === \"bottom\" ) {\n                    position.top -= elemHeight;\n                } else if ( options.my[ 1 ] === \"center\" ) {\n                    position.top -= elemHeight / 2;\n                }\n\n                position.left += myOffset[ 0 ];\n                position.top += myOffset[ 1 ];\n\n                collisionPosition = {\n                    marginLeft: marginLeft,\n                    marginTop: marginTop\n                };\n\n                $.each( [ \"left\", \"top\" ], function( i, dir ) {\n                    if ( $.ui.position[ collision[ i ] ] ) {\n                        $.ui.position[ collision[ i ] ][ dir ]( position, {\n                            targetWidth: targetWidth,\n                            targetHeight: targetHeight,\n                            elemWidth: elemWidth,\n                            elemHeight: elemHeight,\n                            collisionPosition: collisionPosition,\n                            collisionWidth: collisionWidth,\n                            collisionHeight: collisionHeight,\n                            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n                            my: options.my,\n                            at: options.at,\n                            within: within,\n                            elem: elem\n                        } );\n                    }\n                } );\n\n                if ( options.using ) {\n\n                    // Adds feedback as second argument to using callback, if present\n                    using = function( props ) {\n                        var left = targetOffset.left - position.left,\n                            right = left + targetWidth - elemWidth,\n                            top = targetOffset.top - position.top,\n                            bottom = top + targetHeight - elemHeight,\n                            feedback = {\n                                target: {\n                                    element: target,\n                                    left: targetOffset.left,\n                                    top: targetOffset.top,\n                                    width: targetWidth,\n                                    height: targetHeight\n                                },\n                                element: {\n                                    element: elem,\n                                    left: position.left,\n                                    top: position.top,\n                                    width: elemWidth,\n                                    height: elemHeight\n                                },\n                                horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n                                vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n                            };\n                        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n                            feedback.horizontal = \"center\";\n                        }\n                        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n                            feedback.vertical = \"middle\";\n                        }\n                        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n                            feedback.important = \"horizontal\";\n                        } else {\n                            feedback.important = \"vertical\";\n                        }\n                        options.using.call( this, props, feedback );\n                    };\n                }\n\n                elem.offset( $.extend( position, { using: using } ) );\n            } );\n        };\n\n        $.ui.position = {\n            fit: {\n                left: function( position, data ) {\n                    var within = data.within,\n                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n                        outerWidth = within.width,\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n                        overLeft = withinOffset - collisionPosLeft,\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n                        newOverRight;\n\n                    // Element is wider than within\n                    if ( data.collisionWidth > outerWidth ) {\n\n                        // Element is initially over the left side of within\n                        if ( overLeft > 0 && overRight <= 0 ) {\n                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -\n                                withinOffset;\n                            position.left += overLeft - newOverRight;\n\n                            // Element is initially over right side of within\n                        } else if ( overRight > 0 && overLeft <= 0 ) {\n                            position.left = withinOffset;\n\n                            // Element is initially over both left and right sides of within\n                        } else {\n                            if ( overLeft > overRight ) {\n                                position.left = withinOffset + outerWidth - data.collisionWidth;\n                            } else {\n                                position.left = withinOffset;\n                            }\n                        }\n\n                        // Too far left -> align with left edge\n                    } else if ( overLeft > 0 ) {\n                        position.left += overLeft;\n\n                        // Too far right -> align with right edge\n                    } else if ( overRight > 0 ) {\n                        position.left -= overRight;\n\n                        // Adjust based on position and margin\n                    } else {\n                        position.left = max( position.left - collisionPosLeft, position.left );\n                    }\n                },\n                top: function( position, data ) {\n                    var within = data.within,\n                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n                        outerHeight = data.within.height,\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\n                        overTop = withinOffset - collisionPosTop,\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n                        newOverBottom;\n\n                    // Element is taller than within\n                    if ( data.collisionHeight > outerHeight ) {\n\n                        // Element is initially over the top of within\n                        if ( overTop > 0 && overBottom <= 0 ) {\n                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -\n                                withinOffset;\n                            position.top += overTop - newOverBottom;\n\n                            // Element is initially over bottom of within\n                        } else if ( overBottom > 0 && overTop <= 0 ) {\n                            position.top = withinOffset;\n\n                            // Element is initially over both top and bottom of within\n                        } else {\n                            if ( overTop > overBottom ) {\n                                position.top = withinOffset + outerHeight - data.collisionHeight;\n                            } else {\n                                position.top = withinOffset;\n                            }\n                        }\n\n                        // Too far up -> align with top\n                    } else if ( overTop > 0 ) {\n                        position.top += overTop;\n\n                        // Too far down -> align with bottom edge\n                    } else if ( overBottom > 0 ) {\n                        position.top -= overBottom;\n\n                        // Adjust based on position and margin\n                    } else {\n                        position.top = max( position.top - collisionPosTop, position.top );\n                    }\n                }\n            },\n            flip: {\n                left: function( position, data ) {\n                    var within = data.within,\n                        withinOffset = within.offset.left + within.scrollLeft,\n                        outerWidth = within.width,\n                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n                        overLeft = collisionPosLeft - offsetLeft,\n                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n                        myOffset = data.my[ 0 ] === \"left\" ?\n                            -data.elemWidth :\n                            data.my[ 0 ] === \"right\" ?\n                                data.elemWidth :\n                                0,\n                        atOffset = data.at[ 0 ] === \"left\" ?\n                            data.targetWidth :\n                            data.at[ 0 ] === \"right\" ?\n                                -data.targetWidth :\n                                0,\n                        offset = -2 * data.offset[ 0 ],\n                        newOverRight,\n                        newOverLeft;\n\n                    if ( overLeft < 0 ) {\n                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -\n                            outerWidth - withinOffset;\n                        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n                            position.left += myOffset + atOffset + offset;\n                        }\n                    } else if ( overRight > 0 ) {\n                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +\n                            atOffset + offset - offsetLeft;\n                        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n                            position.left += myOffset + atOffset + offset;\n                        }\n                    }\n                },\n                top: function( position, data ) {\n                    var within = data.within,\n                        withinOffset = within.offset.top + within.scrollTop,\n                        outerHeight = within.height,\n                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n                        collisionPosTop = position.top - data.collisionPosition.marginTop,\n                        overTop = collisionPosTop - offsetTop,\n                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n                        top = data.my[ 1 ] === \"top\",\n                        myOffset = top ?\n                            -data.elemHeight :\n                            data.my[ 1 ] === \"bottom\" ?\n                                data.elemHeight :\n                                0,\n                        atOffset = data.at[ 1 ] === \"top\" ?\n                            data.targetHeight :\n                            data.at[ 1 ] === \"bottom\" ?\n                                -data.targetHeight :\n                                0,\n                        offset = -2 * data.offset[ 1 ],\n                        newOverTop,\n                        newOverBottom;\n                    if ( overTop < 0 ) {\n                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -\n                            outerHeight - withinOffset;\n                        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {\n                            position.top += myOffset + atOffset + offset;\n                        }\n                    } else if ( overBottom > 0 ) {\n                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +\n                            offset - offsetTop;\n                        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {\n                            position.top += myOffset + atOffset + offset;\n                        }\n                    }\n                }\n            },\n            flipfit: {\n                left: function() {\n                    $.ui.position.flip.left.apply( this, arguments );\n                    $.ui.position.fit.left.apply( this, arguments );\n                },\n                top: function() {\n                    $.ui.position.flip.top.apply( this, arguments );\n                    $.ui.position.fit.top.apply( this, arguments );\n                }\n            }\n        };\n\n    } )();\n\n    var position = $.ui.position;\n\n\n\n\n}));"]}